# Linux基础

## 常用快捷软件

- cal 日历
- date 日期时间
- bc 计算器

## 常用热键

- ctrl+c 终止进程
- tab 单击自动补全 双击展示相关指令
- ctrl+d 输入终止
- ctrl+alt+t 快速打开终端
- ptsc 打开截图

## 常用查询指令

### man 指令名

man page 详细

| 代号 | 代表内容 |
| --- | --- |
| 1 | 使用者在shell环境中可以操作的命令或可运行文件 |
| 2 | 系统核心可呼叫的函数与工具等 |
| 3 | 一些常用的函数(function)与函式库(library)，大部分为C的函式库(libc) |
| 4 | 装置文件的说明，通常在/dev下的文件 |
| 5 | 配置文件或者是某些文件的格式 |
| 6 | 游戏(games) |
| 7 | 惯例与协议等，例如Linux文件系统、网络协议、ASCII code等等的说明 |
| 8 | 系统管理员可用的管理命令 |
| 9 | 跟kernel有关的文件 |

指令后面的数字代表信息
man page大致分成底下这几个部分：

| 代号 | 内容说明 |
| --- | --- |
| NAME | 简短的命令、数据名称说明 |
| SYNOPSIS | 简短的命令下达语法(syntax)简介 |
| DESCRIPTION | 较为完整的说明，这部分最好仔细看看！ |
| OPTIONS | 针对 SYNOPSIS 部分中，有列举的所有可用的选项说明 |
| COMMANDS | 当这个程序(软件)在运行的时候，可以在此程序(软件)中下达的命令 |
| FILES | 这个程序或数据所使用或参考或连结到的某些文件 |
| SEE ALSO | 可以参考的，跟这个命令或数据有相关的其他说明！ |
| EXAMPLE | 一些可以参考的范例 |
| BUGS | 是否有相关的臭虫！ |

在man page搜索
当你按下『/』之后，光标就会移动到屏幕的最下面一行， 并等待你输入搜寻的字符串了

| 按键 | 进行工作 |
| --- | --- |
| 空格键 | 向下翻一页 |
| [Page Down] | 向下翻一页 |
| [Page Up] | 向上翻一页 |
| [Home] | 去到第一页 |
| [End] | 去到最后一页 |
| /string | 向『下』搜寻 string 这个字符串，如果要搜寻 vbird 的话，就输入 /vbird |
| ?string | 向『上』搜寻 string 这个字符串 |
| n, N | 利用 / 或 ? 来搜寻字符串时，可以用 n 来继续下一个搜寻 (不论是 / 或 ?) ，可以利用 N 来进行『反向』搜寻。举例来说，我以 /vbird 搜寻 vbird 字符串， 那么可以 n 继续往下查询，用 N 往上查询。若以 ?vbird 向上查询 vbird 字符串， 那我可以用 n 继续『向上』查询，用 N 反向查询。 |
| q | 结束这次的 man page |

### info 指令名

| 按键 | 进行工作 |
| --- | --- |
| 空格键 | 向下翻一页 |
| [Page Down] | 向下翻一页 |
| [Page Up] | 向上翻一页 |
| [tab] | 在 node 之间移动，有 node 的地方，通常会以 * 显示。 |
| [Enter] | 当光标在 node 上面时，按下 Enter 可以进入该 node 。 |
| b | 移动光标到该 info 画面当中的第一个 node 处 |
| e | 移动光标到该 info 画面当中的最后一个 node 处 |
| n | 前往下一个 node 处 |
| p | 前往上一个 node 处 |
| u | 向上移动一层 |
| s(/) | 在 info page 当中进行搜寻 |
| h | 显示求助菜单 |
| ? | 命令一览表 |
| q | 结束这次的 info page |

### /usr/share/doc目录

打开/usr/share/doc目录查看里面的文档

## 常用指令

- who 输出是谁在使用计算机
- netstat -a 查看联机状态
- ps -aux 查看进程
- shutdown 关机
- reboot 重启
- sync 数据同步写入磁盘
- init 切换运行等级
  - run level 0：关机
  - run level 3：纯文本模式
  - run level 5：含有图形接口模式
  - run level 6：重新启动
- ls -al 查看文件属性

## 忘记 root 密码

先将系统重新启动，在读秒的时候按下任意键就会出现菜单画面，仔细看菜单底下的说明， 按下『e』就能够进入grub的编辑模式了。此时你看到的画面有点像底下这样：

| root (hd0,0)  kernel /vmlinuz-2.6.18-128.el5 ro root=LABEL=/ rhgb quiet  initrd /initrd-2.6.18-128.el5.img   |
| --- |

此时，请将光标移动到kernel那一行，再按一次『 e 』进入kernel该行的编辑画面中， 然后在出现的画面当中，最后方输入 single ：

| kernel /vmlinuz-2.6.18-128.el5 ro root=LABEL=/ rhgb quiet single   |
| --- |

再按下『 Enter 』确定之后，按下 b 就可以启动进入单人维护模式了！ 在这个模式底下，你会在tty1的地方不需要输入密码即可取得终端机的控制权(而且是使用root的身份喔！)。 之后就能够修改root的密码了！请使用底下的命令来修改root的密码喔！

| [root@www ~]# passwd  # 接下来系统会要求你输入两次新的密码，然后再来reboot即可顺利修订root密码了！   |
| --- |

## 文件管理

### 列出目录内容

`ls 目录`
递归 -R

### 基本管理

- cp 用于复制一个或多个文件或目录
- mv 用于移动 或重命名 一个或多个文件或目录。inode 号只有在文件被移动到另一文件系统才会发生。
- rm 用于删除 一个或多个文件。

### 目录创建和删除

- mkdir 可以一次处理多个目录创建请求
- rmdir 命令删除目录正好与创建过程相反。可以用 -p 选项来删除父目录

### 文件创建

- touch
- vim

### 通配符

- ? 匹配任何单个字符
  - * 匹配任何字符串
- [ 引入一个字符类

### Touch

- touch 命令使用一个或多个文件名作为参数，并将更新文件的修改时间
- touch 通常会创建一个空文件，除非指定了 -c 或 --no-create 选项
- touch 命令还可以将文件的修改时间（也称为 mtime）设置为一个特定日期和时间，可以使用 -d 或 -t 选项。-d 可以非常灵活地处理它将接受的日期和时间格式，而 -t 选项需要至少一个 MMDDhhmm 时间，年份和秒数是可选的。

### 查找文件

`find [路径] [参数]`
**常用参数**：

| -name | 匹配名称 |
| --- | --- |
| -perm | 匹配权限（mode为完全匹配，-mode为包含即可） |
| -user | 匹配所有者 |
| -group | 匹配所有组 |
| -mtime -n +n | 匹配修改内容的时间（-n指n天以内，+n指n天以前） |
| -atime -n +n | 匹配访问文件的时间（-n指n天以内，+n指n天以前） |
| -ctime -n +n | 匹配修改文件权限的时间（-n指n天以内，+n指n天以前） |
| -nouser | 匹配无所有者的文件 |
| -nogroup | 匹配无所有组的文件 |
| -newer f1 !f2 | 匹配比文件f1新但比f2旧的文件 |
| -type b/d/c/p/l/f | 匹配文件类型（后面的字幕字母依次表示块设备、目录、字符设备、管道、链接文件、文本文件） |
| -size | 匹配文件的大小（+50KB为查找超过50KB的文件，而-50KB为查找小于50KB的文件） |
| -prune | 忽略某个目录 |
| -exec …… {}\\; | 后面可跟用于进一步处理搜索结果的命令 |

### 压缩文件

- gzip 和 gunzip
  - 在windows下解压gz使用7-ZIP
| -a | 使用ASCII文字模式 |
| --- | --- |
| -d | 解开压缩文件 |
| -f | 强行压缩文件 |
| -k | 保留原文件 |
| -l | 列出压缩文件的相关信息 |
| -c | 把压缩后的文件输出到标准输出设备，不去更动原始文件 |
| -r | 递归处理，将指定目录下的所有文件及子目录一并处理 |
| -q | 不显示警告信息 |

- bzip2 和 bunzip2
| -c | 将压缩与解压缩的结果送到标准输出 |
| --- | --- |
| -d | 执行解压缩 |
| -f | bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖，请使用此参数 |
| -k | bzip2在压缩或解压缩后，会删除原始的文件。若要保留原始文件，请使用此参数 |
| -s | 降低程序执行时内存的使用量 |
| -t | 测试.bz2压缩文件的完整性 |
| -v | 压缩或解压缩文件时，显示详细的信息 |
| -z | 强制执行压缩 |

- tar

`tar 参数 文件或目录`

| -A | 新增文件到以存在的备份文件 |
| --- | --- |
| -B | 设置区块大小 |
| -c | 建立新的备份文件 |
| -C <目录> | 仅压缩指定目录里的内容或解压缩到指定目录 |
| -d | 记录文件的差别 |
| -x | 从归档文件中提取文件 |
| -t | 列出备份文件的内容 |
| -z | 通过gzip指令压缩/解压缩文件，文件名最好为*.tar.gz |
| -Z | 通过compress指令处理备份文件 |
| -f<备份文件> | 指定备份文件 |
| -v | 显示指令执行过程 |
| -r | 添加文件到已经压缩的文件 |
| -u | 添加改变了和现有的文件到已经存在的压缩文件 |
| -j | 通过bzip2指令压缩/解压缩文件，文件名最好为*.tar.bz2 |
| -v | 显示操作过程 |
| -l | 文件系统边界设置 |
| -k | 保留原有文件不覆盖 |
| -m | 保留文件不被覆盖 |
| -w | 确认压缩文件的正确性 |
| -p | 保留原来的文件权限与属性 |
| -P | 使用文件名的绝对路径，不移除文件名称前的“/”号 |
| -N <日期格式> | 只将较指定日期更新的文件保存到备份文件里 |
| -- -exclude=<范本样式> | 排除符合范本样式的文件 |
| -- -remove-files | 归档/压缩之后删除源文件 |

### 文件系统对象

| 代码 | 对象类型 |
| --- | --- |
| - | 常规文件 |
| d | 目录 |
| l | 符号链接 |
| c | 字符特殊设备 |
| b | 模块特殊设备 |
| p | FIFO（命令管道） |
| s | 套接字 |

### 文件属性和权限操作

- chgrp ：改变文件所属群组
  - chgrp [-R] dirname/filename ...
    - 选项与参数： -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件、目录      都更新成为这个群组之意。常常用在变更某一目录内所有的文件之情况。
- chown ：改变文件拥有者
  - chown [-R] 账号名称 文件或目录
  - chown [-R] 账号名称:组名 文件或目录
- chmod ：改变文件的权限, SUID, SGID, SBIT等等的特性
| chmod | u
g
o
a | +(加入)
-(除去)
=(设定) | r
w
x | 文件或目录 |
| --- | --- | --- | --- | --- |

### suid和sgid

suid（设置用户 id）和 sgid（设置组 id）。当可执行的程序设置为 suid 访问模式，它在运行时好像是由文件所有者启动而不是由真正启动它的用户启动。类似的，设置为 sgid访问模式，程序就会运行，好像启动用户属于文件组，而不属于他所有的组。可以单独或者同时设置两个访问模式。suid 和 sgid 位与长目录清单中用户和组的 x 占据相同的空间。如果文件是可执行的，suid 或 sgid 位如果已设置，将会显示为小写的 s，否则就显示为大写的 S。

### 粘贴位

-t 让文件目录下文件所有者可以删除自己所有的文件，别人无法删除

### 不可变文件

设置之后root用户也无法删除
使用chattr 命令和 -i 标识`chattr +i 文件名/目录名`
使用lsattr查看是否设置了不可变标识 `lsattr 文件名/目录名`

### 文件创建屏蔽

控制新创建的文件的权限
`umask`
使用 -S 选项来从符号上显示 umask，以显示哪个权限被允许的形式

### 文件目录配置

|  | 可分享的(shareable) | 不可分享的(unshareable) |
| --- | --- | --- |
| 不变的(static) | /usr (软件放置处) | /etc (配置文件) |
|  | /opt (第三方协力软件) | /boot (开机与核心档) |
| 可变动的(variable) | /var/mail (使用者邮件信箱) | /var/run (程序相关) |
|  | /var/spool/news (新闻组) | /var/lock (程序相关) |

- / (root, 根目录)：与开机系统有关；
- /usr (unix software resource)：与软件安装/执行有关；
- /var (variable)：与系统运作过程有关。

## shell

### 常见的bash环境变量

| 名称 | 作用 |
| --- | --- |
| USER | 已登录用户的名称 |
| UID | 用数字表示的已登录用户的用户 id |
| HOME | 用户的主目录 |
| PWD | 当前的工作目录 |
| SHELL | shell 的名称 |
| $ | 进程 id（或运行的 bash shell 或其他进程的 PID |
| PPID | 启动当前进程的进程的 id（即父进程的 id） |
| ? | 上一个命令的退出代码 |

### env

显示当前环境变量

- -i 清空环境变量
- -u 取消不想传递的环境变量

### uname

显示系统信息

- -s 输出内核名称（默认）
- -n 输出节点或主机名
- -r 内核发行版
- -v 内核版本
- -m 机器硬件（cpu）名
- -o 操作系统名称
- -a 输出以上所有信息

### 命令行历史

- history 显示完整历史
- history N 显示历史中的最后 N 行
- history -d N 从历史中删除行 N；比如，如果行中包含密码的话就需要这样做
- !! 最近使用的命令
- !N 第 N 个历史命令
- !-N 回到历史中的 N 个命令（!-1 相当于 !!）
- !# 正在输入的当前命令
- !string 以 string 开头的最近一次命令
- !?string? 包含 string 的最近一次命令

### 查找命令

- which 输出命令所在位置
- type 输出命令基本信息

### 查询命令用法

- whatis  显示该命令的执行功能
- apropos [参数] [关键字]

**常用参数：**

| -d | 输出调试信息 |
| --- | --- |
| -l | 不根据终端宽度缩减输出 |
| -w | 将每个keyword作为shell样式的通配符解释 |
| -a | 后面跟参数为查找手册中的关键词 |

## 文本流和过滤器

### 管道操作符（|）

管道操作符 (|) 连接两个命令，可以将命令 command1 的输出作为过滤器
command2 的输入。

### 输出重定向（>）

输出重定向操作符 (>)将输出保存到文件中。

### cat

concatenate 的简写 命令显示 文件在使用标准输出时的内容
常用参数：

| -n | 显示行数（空行也编号） |
| --- | --- |
| -s | 显示行数（多个空行算一个编号） |
| -b | 显示行数（空行不编号） |
| -E | 每行结束处显示$符号 |
| -T | 将TAB字符显示为 ^I符号 |
| -v | 使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外 |
| -e | 等价于”-vE”组合 |
| -t

 | 等价于”-vT”组合 |
| -A | 等价于 -vET组合 |
| --help | 显示帮助信息 |
| --version | 显示版本信息 |

### od

可以查找并解释特殊字符

- `od -b tmp`
- `od -c tmp` 使用单字节八进制解释进行输出
- `od -t d1 tmp` 使用ASCII码进行输出
- `od -A d -c tmp` 使用单字节十进制

### split

可以将一个大文件拆分为 相同大小的块
`split [参数] [切割文件][文件名]`
常用参数：

| 参数 | 描述 |
| --- | --- |
| -b | 指定每多少字节切成一个小文件 |
| --help | 查看帮助信息 |
| --version | 显示版本信息 |
| -C | 与参数”-b”相似，但是在切 割时将尽量维持每行的完整性 |

### wc

查看文件的大小，它将显示文件中所含的行、单词、
字节的数量。
常用参数

| -w | 统计单词数 |
| --- | --- |
| -c | 统计字节数 |
| -l | 统计行数 |
| -m | 统计字符数 |
| -L | 显示最长行的长度 |
| --help | 显示帮助信息 |
| --version | 显示版本信息 |

### head和tail

head和tail这两个命令显示文件的开始部分（head）或结束部分（tail）。默认
情况下，这两个命令将显示文件或流的前 10（或后 10）行。

### expand, unexpand, tr

- expand命令可以将制表符替换为空格。
- unexpand命令可以将空格替换成制表符。
- tr （translates characters）将一个集合（set1）中的字符转换为另一个集合（set2）中的对应字符

### pr, nl, 和 fmt

- pr 命令用于格式化文件以执行输出。默认的头部（header）包含文件名和文件创建日期和时间，以及一个页号和两行空白页脚。
- nl 命令可以对行进行编号，这在输出文件时非常方便。
- fmt 命令将格式化文本以使其能够适合边距，可以联接多个较短的行，以及拆分较长的行。

### sort 和 uniq

- sort 将按照系统的 locale（LC_COLLATE）的排序序列来对输入进行排序。sort命令还可以合并已经排序的文件，并检查某个文件是否已经排序
- uniq 命令通常操作已排序的文件，并从文件（不管是否排序）中删除连续的相同行。

### cut, paste, 和 join

- cut命令可以从文本文件中提取字段。默认的字段分隔符是制表符。
| -c | 以字符为单位进行分割 |
| --- | --- |
| -b | 以字节为单位进行分割 |
| -d | 自定义分隔符，默认为制表符”TAB” |
| -f | 显示指定字段的内容 |
| -n | 取消分割多字节字符 |
| --complement | 补足被选择的字节、字符或字段 |
| --out-delimiter | 指定输出内容是的字段分割符 |

- paste 命令可以并行粘帖来自两个或多个文件的行，其方式类似于 pr 命令使用其-m 选项合并文件。
- join命令根据匹配的字段连接文件。这些文件应当根据 join 字段排序。

### sed

- 替换文本

## 使用流、管道和重定向

### 使用流

- stdout 是标准输出流，它显示来自命令的输出。它的文件描述符为 1。
- stderr 是标准错误流，它显示来自命令的错误输出。它的文件描述符为 2。
- stdin 是标准输入流，它为命令提供输入。它的文件描述符为 0。

可以通过两种方法将输出重定向到文件：
n>
将输出从文件描述符 n 重定向到文件。如果该文件不存在，将创建它。如果该文
件已经存在，**通常将覆盖所有现有内容，并且没有任何警告**。
n>>
还可以将输出从文件描述符 n 重定向到一个文件中。如果该文件不存在，将创建
它。如果该文件已经存在，**输出将附加到现有的内容后面**

### 管道

通过管道将 stdout 导入到 stdin
在两个命令之间使用管道 | 操作符将的一个命令的 stdout 指向第二个命令的stdin。
使用文件而不是 stdout 开始管道线
可以使用 cat 命令将文件复制到 stdout。

### 使用输出作为参数

将一个命令或文件的内容作为另一个命令的参数而不是输入。常见的解决办法是：xargs 命令：读取标准的输入，然后使用参数作为输入构建和执行命令。带有 -exec 选项的 find 命令：使用 find 命令根据名称、修改时间、大小或其他特征查找文件。找到匹配的文件集之后，使用find 命令的 -exec 选项对它们执行某些操作：删除、移动和重命名它们等。其功能类似于使用 find 并通过管道将输出指向 xargs。

### 分离输出

tee 命令我们可以在屏幕上看到输出，同时保留一个副本。
执行某个指定的命令，并将其执行结果即输出到屏幕，又写入到文件中：
`uptime | tee system.txt`

## 创建、监视和终止进程

### 处理前台和后台作业

Ctrl-Z转让后台
fg [作业标识] 重新启动

### 注销之后运行进程

`nohup [参数]`
nohup 命令用于启动一个忽略 hangup 信号的命令，并且将 stdout 和 stderr 附加到文件。默认的文件为 nohup.out 或 $HOME/nohup.out。

### 监视进程

- ps 来显示进程状态信息的不同部分
- jobs 命令与 -p 选项一起使用，输出结果将是每个作业的 process group leader 的PID
- free 命令显示系统的空闲内存和已用内存
- uptime 命令在一行内显示当前时间，系统运行时间，当前登录的用户，以及过去1 分钟、5 分钟和 15 分钟系统的平均负载。
- top 命令显示持续更新的进程列表和有用的摘要信息

### 发送信号

`kill 命令将信号发送到指定的作业或进程`

### 注销和nohup

nohup 命令可以让进程避开 SIGHUP 信号

## 修改进程执行优先级

ps 命令可以使用 -l 选项显示优先级（例如，nice 或 NI、level）。
nice 命令显示我们的默认优先级。

### 更改优先级

`renice [参数]`

| -g | 指定进程组id |
| --- | --- |
| -p | 改变该程序的优先权等级，此参数为预设值 |
| -u | 指定开启进程的用户名 |

将行程id为987及32的进程与进程拥有者为daemon及root的优先序号码加1：
`renice +1 987 -u daemon root -p 32`

## 正则搜索文本文件

- grep
- sed
- awk

`grep [参数] 文件`

| -i | 忽略大小写 |
| --- | --- |
| -c | 只输出匹配行的数量 |
| -l | 只列出符合匹配的文件名，不列出具体的匹配行 |
| -n | 列出所有的匹配行，显示行号 |
| -h | 查询多文件时不显示文件名 |
| -s | 不显示不存在、没有匹配文本的错误信息 |
| -v | 显示不包含匹配文本的所有行 |
| -w | 匹配整词 |
| -x | 匹配整行 |
| -r | 递归搜索 |
| -q | 禁止输出任何结果，已退出状态表示搜索是否成功 |
| -b | 打印匹配行距文件头部的偏移量，以字节为单位 |
| -o | 与-b结合使用，打印匹配的词据文件头部的偏移量，以字节为单位 |
| -F | 匹配固定字符串的内容 |
| -E | 支持扩展的正则表达式 |

- [:alnum:]字母数字字符
- [:blank:]空格和制表符
- [:digit:]数字 0 到 9（等效于 0-9）
- [:upper:] 和 [:lower:]分别为大写字母和小写字母。

## vim

### 文档移动

- h在当前行往左移动一个字符
- j向下移动到下一行
- k向上移动到上一行
- l在当前行往右移动一个字符
- w移动到当前行下一个字
- e移动到当前行下一个字的结束处
- b移动到当前行上一个字的开始处
- Ctrl-f向前滚动一页
- Ctrl-b向后滚动一页
  - 如果在这些命令之前键入数字，则命令将执行该数字表示的次数
- G移动到文件的特定行。例如，3G 移动到第 3 行。如果没有参数，G 将移动到文件的最后一行。
- H相对于屏幕移动到最上面的行。例如，3H 将移动到屏幕上方往下第三行。
- L就像 H 一样，不同之处在于移动到屏幕的最后一行。因此，2L 移动到屏幕的倒数第二行。

### 修改文本

- cw 删除当前字的其余部分，进入插入模式进行替换
- dw 与上述 cw（和 c$）类似，但不进入插入模式
- dd 删除当前行。使用重复计数删除多行。
- x 删除光标位置的字符。使用重复计数删除多个字符。
- p 将最后一个删除文本放在当前字符。使用 P 将其放在当前字符之前。
- xp 组合 x 和 p 是一个常用的方法。这将交换光标位置的字符和它右边的字符。

### 搜索文本

- / 使用 / 后跟正则表达式可以在文件中进行向前搜索。
- ? 使用 ? 后跟正则表达式可以在文件中进行向后搜索。
- n 使用 n 以任意方向重复上一次搜索。

## 维护文件系统

### 检查与修复文件系统

`fsck [参数] 文件系统`

| -a | 自动修复文件系统 |
| --- | --- |
| -f | 强制检查 |
| -A | 依照/etc/fstab文件来检查全部文件系统 |
| -N | 不执行指令，仅列出实际执行会进行的动作 |
| -r | 采用互动模式，在执行修复时询问问题 |
| -R | 略过指定的文件系统不予检查 |
| -t | 指定要检查的文件系统类型 |
| -T | 执行fsck指令时，不显示标题信息 |
| -V | 显示指令执行过程 |

### 监控磁盘可用空间

- df 命令显示挂载的文件系统的相关信息。 如果您添加 -T 选项，那么显示中会包含文件系统的类型；`df [参数] [对象磁盘/分区]`
| -a | 显示所有系统文件 |
| --- | --- |
| -B <块大小> | 指定显示时的块大小 |
| -h | 以容易阅读的方式显示 |
| -H | 以1000字节为换算单位来显示 |
| -i | 显示索引字节信息 |
| -k | 指定块大小为1KB |
| -l | 只显示本地文件系统 |
| -t <文件系统类型> | 只显示指定类型的文件系统 |
| -T | 输出时显示文件系统类型 |
| -- -sync | 在取得磁盘使用信息前，先执行sync命令 |

- du 命令显示参数指定的文件（或多个文件）的相关信息`du [参数] 文件`
| -a | 显示目录中所有文件大小 |
| --- | --- |
| -k | 以KB为单位显示文件大小 |
| -m | 以MB为单位显示文件大小 |
| -h | 以易读方式显示文件大小 |
| -s | 仅显示总计 |

### 修复文件系统

`单用户模式（使用 telinit 1）`

## 文件系统的安装和卸载

### 安装文件系统

`mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点`

| -t | 指定挂载类型 |
| --- | --- |
| -l | 显示已加载的文件系统列表 |
| -h | 显示帮助信息并退出 |
| -V | 显示程序版本 |
| -n | 加载没有写入文件“/etc/mtab”中的文件系统 |
| -r | 将文件系统加载为只读模式 |
| -a | 加载文件“/etc/fstab”中描述的所有文件系统 |

### 卸载文件系统

`umount [参数] [设备/挂载目录]`

- -f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；
- -n ：不升级 /etc/mtab 情况下卸除。

## 管理磁盘配额

`dpkg -l quota`

### 检查安装的文件系统配额

`quotacheck [-adgRuv][文件系统...]`

| -a | 扫描在/etc/fstab文件里，有加入quota设置的分区 |
| --- | --- |
| -d | 详细显示指令执行过程，便于排错或了解程序执行的情形 |
| -g | 扫描磁盘空间时，计算每个群组识别码所占用的目录和文件数目 |
| -R | 排除根目录所在的分区 |
| -u | 扫描磁盘空间时，计算每个用户识别码所占用的目录和文件数目 |

如果只是想要显示配额的开启和关闭，您可以使用 -p选项。使用 quotaoff 命令关闭配额检测。

### 设置配额限制

配额不是通过文件系统 root 中的二进制文件控制，就是通过文件系统元数据控制。为特定用户设置一个配额，要使用 edquota 命令。这个命令会为用户从启用配额的各种文件系统中提取配额信息，创建一个临时文件，并为您打开编辑器来调整配额。通过默认设置，edquota 使用 vi 编辑器。如果您想使用不同的编辑器，设置 EDITOR 或者 VISUAL 变量。编辑用户配额，使用 -u 选项（默认）和一个或者多个用户名。编辑组配额，使用 -g 和一个或者多个组名。您必须是 root 用户，才可以编辑配额

## 硬链接和符号链接

一个硬链接 是指向 inode 的一个目录条目，而一个软链接 或符号链接 是指
向提供另一目录条目名称的 inode 的一个目录条目
硬链接最后一个被删除会删除文件，软链接被删除不会删除文件

- 硬链接 `ln`
- 软链接 `ln -s`

### 识别链接

`ls -li 文件名`

### 查找链接

- 硬链接 `find . -samefile text1`
- 软链接 `find . -lname text1`

## 文件系统架构

`$PATH`

- which 命令您可以使用 which 命令搜索您的路径，并查明在您输入一个命令时会执行哪个命令（如果有的话）
- type 命令有一些命令是 which 命令找不到的，比如 shell 内键指令。type 命令是一个内键指令，告诉您如何评估一个给定命令从而执行该命令。
- whereis 命令如果您需要程序位置以外的更多信息，那么可以使用 whereis 命令。
- find命令
- locate命令比 find 命令快，该命令使用一个存储路径信息的数据库，而不用每次都搜索文件系统;locate 使用的默认数据库存储在 /var 文件系统中，在一个类似/var/lib/locatedb 的位置中。可以使用 locate -S 查找有关 locate 数据库的统计信息，数据库是使用 updatedb 命令予以创建和更新的（可能需要安装mlocate）

### FHS目录

| 目录 | 用途 |
| --- | --- |
| bin | 必需的命令二进制文件 |
| boot | 启动加载程序的静态文件 |
| dev | 设备文件 |
| etc | 特定于主机的系统配置 |
| lib | 必需的共享库和内核模块 |
| media | 可移动媒体的装入点 |
| mnt | 临时安装文件系统的装入点 |
| opt | 附加应用程序软件包 |
| sbin | 必需的系统二进制文件 |
| srv | 本系统提供的服务用数据 |
| tmp | 临时文件 |
| usr | 二级层次结构 |
| var | 变量数据 |
| home | 用户主目录（可选） |
| lib<qual> | 备用格式必需的共享库（可选） |
| root | 根用户的主目录（可选） |

## 启动和关闭系统

Linux的基本运行级别
0 关闭(或停止)系统
1 但用户模式；通常别称为S或s
6 重启系统
2 没有联网的多用户模式
3 联网的多用户模式
5 联网并且使用X Window系统的多用户模式
`runlevel查看运行级别`

### 干净关闭

`shutdown`
默认情况下，shutdown 会转换到运行级别 1（单用户模式）。您可以指定 -h
选项来停止系统，也可以指定 -r 选项来重启系统。
`reboot [-n] [-w] [-d] [-f] [-i]`

- -n : 在重开机前不做将记忆体资料写回硬盘的动作
- -w : 并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里
- -d : 不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）
- -f : 强迫重开机，不呼叫 shutdown 这个指令
- -i : 在重开机之前先把所有网络相关的装置先停止

## 包管理

`apt`

- install 安装
- remove 卸载
- autoremove 自动卸载依赖
- update 更新包列表

`dpkg`
介质级包管理工具
用户常常希望知道一个包中有哪些文件，或者某个文件来自哪个包。dpkg 可以完成这两个任务，分别是-L和-S选项。

### 其他工具

`aptitude`
比atp-get在处理依赖上会卸载时卸载依赖

---

除了 aptitude 之外，还有另外几种用于 Debian 系统的交互式包管理界面，包括 dselect、synaptic、update-manager、gnome-apt 和 wajig。synaptic是在 X Window System 上使用的图形化应用程序

### RPM和YUM

rpm不能解决依赖问题，但可以不按次序安装
yum可以解决依赖问题

# Linux安装Nodejs

`tar -zxvf ./node-v16.19.0-linux-x64.tar.gz`
`sudo mv node-v16.19.0-linux-x64 /usr/local/bin`
`vi ~/.bashrc`(如果不能使用全局包可以设置NPM_GLOBALS=/usr/local/n/versions/node/{NODE VERSION}/bin
PATH=$NPM_GLOBALS:$PATH)
然后重新启动您的控制台或直接运行 `source ~/.bashrc`
`sudo vi /etc/environment`
`PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/usr/local/bin/node-v16.19.0-linux-x64/bin:/snap/bin"`

# Linux常用命令

修改文件权限
`sudo chmod 644 ×××` （所有者有读和写的权限，组用户只有读的权限）

`sudo chmod 777 ×××`（每个人都有读和写以及执行的权限）

`sudo chmod 444 /etc/environment` 只读权限

查询`ip`
`ifconfig`

使用`navtic`连接虚拟机`mysql`时关闭防火墙
`systemctl stop firewalld`

## 查看文件内容

`cat`

## 查看进程号

`ps -aux`查看全部进程

搜索进程 `ps -ef|grep 进程名`

杀进程`kill 进程号`

## apt

`apt update`

`apt install`

`apt upgrade`

`pwd` 查看当前路径

## 查看端口占用

lsof -i:端口号

## 安装deb包

- 安装 `sudo dpkg -i package.deb`
- 查看 dpkg -c package.deb
- 移除 dpkg -r package
- 完全清除 dpkg -P package

[参考文献](https://wenku.baidu.com/view/79c537686aeae009581b6bd97f1922791688bea8.html)

## node环境设置

- 安装nodejs

- 安装nvm

  - `curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash`

  - `vim /etc/profile`

  - ```txt
    export NVM_DIR="$HOME/.nvm"
    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
    ```

  - `source /etc/profile`

## shell 脚本

- `echo`命令的作用是在屏幕输出一行文本，可以将该命令的参数原样输出。如果想要输出的是多行文本，即包括换行符。这时就需要把多行文本放在引号里面。
  - 换行用`shift+enter`
  - 默认情况下，`echo`输出的文本末尾会有一个回车符。`-n`参数可以取消末尾的回车符，使得下一个提示符紧跟在输出内容的后面。
  - `-e`参数会解释引号（双引号和单引号）里面的特殊字符（比如换行符`\n`）。如果不使用`-e`参数，即默认情况下，引号会让特殊字符变成普通字符，`echo`不解释它们，原样输出。

命令行环境中，主要通过使用 Shell 命令，进行各种操作。Shell 命令基本都是下面的格式。

```shell
command [ arg1 ... [ argN ]]
```

### 命令组合符

除了分号，Bash 还提供两个命令组合符`&&`和`||`，允许更好地控制多个命令之间的继发关系。

### type命令

`type`命令用来判断命令的来源。

`type`命令的`-t`参数，可以返回一个命令的类型：别名（alias），关键词（keyword），函数（function），内置命令（builtin）和文件（file）

如果要查看一个命令的所有定义，可以使用`type`命令的`-a`参数。

### 快捷键

- `Ctrl + L`：清除屏幕并将当前行移到页面顶部。
- `Ctrl + C`：中止当前正在执行的命令。
- `Shift + PageUp`：向上滚动。
- `Shift + PageDown`：向下滚动。
- `Ctrl + U`：从光标位置删除到行首。
- `Ctrl + K`：从光标位置删除到行尾。
- `Ctrl + W`：删除光标位置前一个单词。
- `Ctrl + D`：关闭 Shell 会话。
- `↑`，`↓`：浏览已执行命令的历史记录。

### 模式扩展

Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元（token）。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。

这种特殊字符的扩展，称为模式扩展（globbing）。其中有些用到通配符，又称为通配符扩展（wildcard expansion）。Bash 一共提供八种扩展。

- 波浪线扩展
- `?` 字符扩展
- `*` 字符扩展
- 方括号扩展
- 大括号扩展
- 变量扩展
- 子命令扩展
- 算术扩展

Bash 允许用户关闭扩展。

```shell
$ set -o noglob
# 或者
$ set -f
```

下面的命令可以重新打开扩展。

```shell
$ set +o noglob
# 或者
$ set +f
```

#### 波浪线扩展

波浪线`~`会自动扩展成当前用户的主目录。

`~/dir`表示扩展成主目录的某个子目录，`dir`是主目录里面的一个子目录名。

`~+`会扩展成当前所在的目录，等同于`pwd`命令。

#### ？字符扩展

`?`字符代表文件路径里面的任意单个字符，不包括空字符。比如，`Data???`匹配所有`Data`后面跟着三个字符的文件名。

如果匹配多个字符，就需要多个`?`连用。

#### * 字符扩展

`*`字符代表文件路径里面的任意数量的任意字符，包括零个字符。

注意，`*`不会匹配隐藏文件（以`.`开头的文件），即`ls *`不会输出隐藏文件。

如果要匹配隐藏文件，需要写成`.*`。

`*`只匹配当前目录，不会匹配子目录。

#### 方括号扩展

方括号扩展的形式是`[...]`，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。括号之中的任意一个字符。

#### [start-end] 扩展

方括号扩展有一个简写形式`[start-end]`，表示匹配一个连续的范围。比如，`[a-c]`等同于`[abc]`，`[0-9]`匹配`[0123456789]`。

#### 大括号扩展

大括号扩展`{...}`表示分别扩展成大括号里面的所有值，各个值之间使用逗号分隔。比如，`{1,2,3}`扩展成`1 2 3`。

#### {start..end} 扩展

大括号扩展有一个简写形式`{start..end}`，表示扩展成一个连续序列。比如，`{a..z}`可以扩展成26个小写英文字母。

#### 变量扩展

Bash 将美元符号`$`开头的词元视为变量，将其扩展成变量值

变量名除了放在美元符号后面，也可以放在`${}`里面。

#### 子命令扩展

`$(...)`可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。

`$(...)`可以嵌套，比如`$(ls $(pwd))`。

#### 算术扩展

`$((...))`可以扩展成整数运算的结果

#### 字符类

`[[:class:]]`表示一个字符类，扩展成某一类特定字符之中的一个。常用的字符类如下。

- `[[:alnum:]]`：匹配任意英文字母与数字
- `[[:alpha:]]`：匹配任意英文字母
- `[[:blank:]]`：空格和 Tab 键。
- `[[:cntrl:]]`：ASCII 码 0-31 的不可打印字符。
- `[[:digit:]]`：匹配任意数字 0-9。
- `[[:graph:]]`：A-Z、a-z、0-9 和标点符号。
- `[[:lower:]]`：匹配任意小写字母 a-z。
- `[[:print:]]`：ASCII 码 32-127 的可打印字符。
- `[[:punct:]]`：标点符号（除了 A-Z、a-z、0-9 的可打印字符）。
- `[[:space:]]`：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13）。
- `[[:upper:]]`：匹配任意大写字母 A-Z。
- `[[:xdigit:]]`：16进制字符（A-F、a-f、0-9）。

#### 使用注意点

通配符有一些使用注意点，不可不知。

**（1）通配符是先解释，再执行。**

Bash 接收到命令以后，发现里面有通配符，会进行通配符扩展，然后再执行命令。

**（2）文件名扩展在不匹配时，会原样输出。**

文件名扩展在没有可匹配的文件时，会原样输出。

**（3）只适用于单层路径。**

所有文件名扩展只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，`?`或`*`这样的通配符，不能匹配路径分隔符（`/`）。

**（4）文件名可以使用通配符。**

Bash 允许文件名使用通配符，即文件名包括特殊字符。这时引用文件名，需要把文件名放在单引号或双引号里面。

#### 量词语法

量词语法用来控制模式匹配的次数。它只有在 Bash 的`extglob`参数打开的情况下才能使用，不过一般是默认打开的。下面的命令可以查询。

```shell
$ shopt extglob
extglob         on
```

如果`extglob`参数是关闭的，可以用下面的命令打开。

```shell
shopt -s extglob
```

量词语法有下面几个。

- `?(pattern-list)`：模式匹配零次或一次。
- `*(pattern-list)`：模式匹配零次或多次。
- `+(pattern-list)`：模式匹配一次或多次。
- `@(pattern-list)`：只匹配一次模式。
- `!(pattern-list)`：匹配给定模式以外的任何内容。

#### shopt 命令

`shopt`命令可以调整 Bash 的行为。它有好几个参数跟通配符扩展有关。

`shopt`命令的使用方法如下。

```shell
# 打开某个参数
$ shopt -s [optionname]

# 关闭某个参数
$ shopt -u [optionname]

# 查询某个参数关闭还是打开
$ shopt [optionname]
```

**（1）dotglob 参数**

`dotglob`参数可以让扩展结果包括隐藏文件（即点开头的文件）。

正常情况下，扩展结果不包括隐藏文件。

**（2）nullglob 参数**

`nullglob`参数可以让通配符不匹配任何文件名时，返回空字符。

默认情况下，通配符不匹配任何文件名时，会保持不变。

**（3）failglob 参数**

`failglob`参数使得通配符不匹配任何文件名时，Bash 会直接报错，而不是让各个命令去处理。

**（4）extglob 参数**

`extglob`参数使得 Bash 支持 ksh 的一些扩展语法。它默认应该是打开的。

**（5）nocaseglob 参数**

`nocaseglob`参数可以让通配符扩展不区分大小写。

**（6）globstar 参数**

`globstar`参数可以使得`**`匹配零个或多个子目录。该参数默认是关闭的。

### 引号和转义

#### 转义

如果想要原样输出这些特殊字符，就必须在它们前面加上反斜杠，使其变成普通字符。这就叫做“转义”（escape）。

反斜杠除了用于转义，还可以表示一些不可打印的字符。

- `\a`：响铃
- `\b`：退格
- `\n`：换行
- `\r`：回车
- `\t`：制表符

如果想要在命令行使用这些不可打印的字符，可以把它们放在引号里面，然后使用`echo`命令的`-e`参数。

```shell
echo -e "\a"
```

#### 单引号

Bash 允许字符串放在单引号或双引号之中，加以引用。

单引号用于保留字符的字面含义，各种特殊字符在单引号里面，都会变为普通字符，比如星号（`*`）、美元符号（`$`）、反斜杠（`\`）等。

#### 双引号

双引号比单引号宽松，大部分特殊字符在双引号里面，都会失去特殊含义，变成普通字符。

但是，三个特殊字符除外：美元符号（`$`）、反引号\`和反斜杠（`\`）。这三个字符在双引号之中，依然有特殊含义，会被 Bash 自动扩展。

双引号会原样保存多余的空格。

#### Here 文档

Here 文档（here document）是一种输入多行字符串的方法，格式如下。

```shell
<< token
text
token
```

它的格式分成开始标记（`<< token`）和结束标记（`token`）。开始标记是两个小于号 + Here 文档的名称，名称可以随意取，后面必须是一个换行符；结束标记是单独一行顶格写的 Here 文档名称，如果不是顶格，结束标记不起作用。两者之间就是多行字符串的内容。

因为 Here 文档对于`echo`命令无效。

此外，Here 文档也不能作为变量的值，只能用于命令的参数。

##### Here 字符串

Here 文档还有一个变体，叫做 Here 字符串（Here string），使用三个小于号（`<<<`）表示。

```
<<< string
```

它的作用是将字符串通过标准输入，传递给命令。

有些命令直接接受给定的参数，与通过标准输入接受参数，结果是不一样的。所以才有了这个语法，使得将字符串通过标准输入传递给命令更方便，比如`cat`命令只接受标准输入传入的字符串。

### 变量

#### 环境变量

`env`命令或`printenv`命令，可以显示所有环境变量。

下面是一些常见的环境变量。

- `BASHPID`：Bash 进程的进程 ID。
- `BASHOPTS`：当前 Shell 的参数，可以用`shopt`命令修改。
- `DISPLAY`：图形环境的显示器名字，通常是`:0`，表示 X Server 的第一个显示器。
- `EDITOR`：默认的文本编辑器。
- `HOME`：用户的主目录。
- `HOST`：当前主机的名称。
- `IFS`：词与词之间的分隔符，默认为空格。
- `LANG`：字符集以及语言编码，比如`zh_CN.UTF-8`。
- `PATH`：由冒号分开的目录列表，当输入可执行程序名后，会搜索这个目录列表。
- `PS1`：Shell 提示符。
- `PS2`： 输入多行命令时，次要的 Shell 提示符。
- `PWD`：当前工作目录。
- `RANDOM`：返回一个0到32767之间的随机数。
- `SHELL`：Shell 的名字。
- `SHELLOPTS`：启动当前 Shell 的`set`命令的参数，参见《set 命令》一章。
- `TERM`：终端类型名，即终端仿真器所用的协议。
- `UID`：当前用户的 ID 编号。
- `USER`：当前用户的用户名。

注意，Bash 变量名区分大小写，`HOME`和`home`是两个不同的变量。

查看单个环境变量的值，可以使用`printenv`命令或`echo`命令。

```
$ printenv PATH
# 或者
$ echo $PATH
```

注意，`printenv`命令后面的变量名，不用加前缀`$`。

#### 自定义变量

自定义变量是用户在当前 Shell 里面自己定义的变量，仅在当前 Shell 可用。一旦退出当前 Shell，该变量就不存在了。

`set`命令可以显示所有变量（包括环境变量和自定义变量），以及所有的 Bash 函数。

#### 创建变量

用户创建变量的时候，变量名必须遵守下面的规则。

- 字母、数字和下划线字符组成。
- 第一个字符必须是一个字母或一个下划线，不能是数字。
- 不允许出现空格和标点符号。

变量声明的语法如下。

```
variable=value
```

上面命令中，等号左边是变量名，右边是变量。注意，等号两边不能有空格。

如果变量的值包含空格，则必须将值放在引号中。

Bash 没有数据类型的概念，所有的变量值都是字符串。

变量可以重复赋值，后面的赋值会覆盖前面的赋值。

如果同一行定义多个变量，必须使用分号（`;`）分隔。

#### 读取变量

读取变量的时候，直接在变量名前加上`$`就可以了。

每当 Shell 看到以`$`开头的单词时，就会尝试读取这个变量名对应的值。

如果变量不存在，Bash 不会报错，而会输出空字符。

由于`$`在 Bash 中有特殊含义，把它当作美元符号使用时，一定要非常小心，注意转义

读取变量的时候，变量名也可以使用花括号`{}`包围，比如`$a`也可以写成`${a}`。这种写法可以用于变量名与其他字符连用的情况。

#### 删除变量

`unset`命令用来删除一个变量。

#### 输出变量，export 命令

用户创建的变量仅可用于当前 Shell，子 Shell 默认读取不到父 Shell 定义的变量。为了把变量传递给子 Shell，需要使用`export`命令。这样输出的变量，对于子 Shell 来说就是环境变量。

`export`命令用来向子 Shell 输出变量。

#### 特殊变量

Bash 提供一些特殊变量。这些变量的值由 Shell 提供，用户不能进行赋值。

（1）`$?`

`$?`为上一个命令的退出码，用来判断上一个命令是否执行成功。返回值是`0`，表示上一个命令执行成功；如果不是零，表示上一个命令执行失败。

（2）`$$`

`$$`为当前 Shell 的进程 ID。

（3）`$_`

`$_`为上一个命令的最后一个参数。

（4）`$!`

`$!`为最近一个后台执行的异步命令的进程 ID。

（5）`$0`

`$0`为当前 Shell 的名称（在命令行直接执行时）或者脚本名（在脚本中执行时）。

（6）`$-`

`$-`为当前 Shell 的启动参数。

#### 变量的默认值

Bash 提供四个特殊语法，跟变量的默认值有关，目的是保证变量不为空。

```shell
${varname:-word}
```

上面语法的含义是，如果变量`varname`存在且不为空，则返回它的值，否则返回`word`。它的目的是返回一个默认值，比如`${count:-0}`表示变量`count`不存在时返回`0`。

```shell
${varname:=word}
```

上面语法的含义是，如果变量`varname`存在且不为空，则返回它的值，否则将它设为`word`，并且返回`word`。它的目的是设置变量的默认值，比如`${count:=0}`表示变量`count`不存在时返回`0`，且将`count`设为`0`。

```shell
${varname:+word}
```

上面语法的含义是，如果变量名存在且不为空，则返回`word`，否则返回空值。它的目的是测试变量是否存在，比如`${count:+1}`表示变量`count`存在时返回`1`（表示`true`），否则返回空值。

```shell
${varname:?message}
```

上面语法的含义是，如果变量`varname`存在且不为空，则返回它的值，否则打印出`varname: message`，并中断脚本的执行。如果省略了`message`，则输出默认的信息“parameter null or not set.”。它的目的是防止变量未定义，比如`${count:?"undefined!"}`表示变量`count`未定义时就中断执行，抛出错误，返回给定的报错信息`undefined!`

上面四种语法如果用在脚本中，变量名的部分可以用数字`1`到`9`，表示脚本的参数。

```shell
filename=${1:?"filename missing."}
```

上面代码出现在脚本中，`1`表示脚本的第一个参数。如果该参数不存在，就退出脚本并报错。

#### declare 命令

`declare`命令可以声明一些特殊类型的变量，为变量设置一些限制，比如声明只读类型的变量和整数类型的变量。

它的语法形式如下。

```
declare OPTION VARIABLE=value
```

`declare`命令的主要参数（OPTION）如下。

- `-a`：声明数组变量。
- `-f`：输出所有函数定义。
- `-F`：输出所有函数名。
- `-i`：声明整数变量。
- `-l`：声明变量为小写字母。
- `-p`：查看变量信息。
- `-r`：声明只读变量。
- `-u`：声明变量为大写字母。
- `-x`：该变量输出为环境变量。

`declare`命令如果用在函数中，声明的变量只在函数内部有效，等同于`local`命令。

#### let 命令

`let`命令声明变量时，可以直接执行算术表达式。

`let`命令的参数表达式如果包含空格，就需要使用引号。

`let`可以同时对多个变量赋值，赋值表达式之间使用空格分隔。
