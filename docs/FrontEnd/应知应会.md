
# 前端应知应会

## javascript

### 手写函数

#### apply

```js
// apply
Function.prototype.myapply = function (thisArg, args) {
  const _this = this;
  if (thisArg === null) {
    thisArg = window || global
  }
  if (typeof _this != "function") {
    throw new Error("not function")
  }
  thisArg.fn = _this
  let res = thisArg.fn(...args)
  delete thisArg.fn
  return res
}


const module = {
  x: 42,
  getX: function () {
    return this.x;
  }
};
```

#### bind

```js
// bind
Function.prototype.mybind = function (thisArg, ...args) {
  const _this = this;
  if (thisArg === null) {
    thisArg = window || global
  }
  if (typeof _this != "function") {
    throw new Error("not function")
  }
  return function (...otherArgs) {
    let res = _this.myapply(thisArg, args.concat(otherArgs))
    return res
  }
}
```

#### call

```js
// call
Function.prototype.mycall = function (thisArg, ...args) {
  const _this = this;
  if (thisArg === null) {
    thisArg = window || global
  }
  if (typeof _this != "function") {
    throw new Error("not function")
  }
  let res = _this.myapply(thisArg, args)
  return res
}

const unboundGetX = module.getX;
// console.log(unboundGetX());//undefined

const boundGetX = unboundGetX.mycall(module);
// console.log(boundGetX);

const numbers = [5, 6, 2, 3, 7];

const max = Math.max.myapply(null, numbers);

// console.log(max);
// expected output: 7

const min = Math.min.apply(null, numbers);

// console.log(min);
// 2
```

#### 防抖

```js
// 防抖和节流都是为了限制高频事件触发次数
// 防抖，多次操作执行最后一次
function debounce(fun, delay) {
  let timer = null
  return function () {
    if (timer !== null) {
      clearTimeout(timer)
    }
    timer = setTimeout(() => {
      fun(this)
    }, delay)
  }
}
```

#### 节流

```js
// 节流,单位时间内执行一次
function throttle(fn, wait) {
  let start = 0
  return function () {
    let now = new Date().getTime()
    if (now - start > wait) {
      fn()
      start = now
    }
  }
}

// 定时器实现节流
function throttle1(fn, wait) {
  let lock = true
  return function () {
    if (lock) {
      lock = false
      setTimeout(() => {
        lock = true
        fn()
      }, wait)
    }
  }
}
```

```js
// 解决输出0-9
for (var i = 0; i < 10; i++) {
  setTimeout(() => {
    console.log(i)
  }, 1000)
}*/

for (var i = 0; i < 10; i++) {
  ((i) => {
    setTimeout(() => {
      console.log(i)
    }, 1000);
  })(i)
}
```

#### 数组扁平化flat

```js
// 数组扁平化flat
// 非递归
Array.prototype.myflat = function (deeps) {
  if (deeps == undefined) {
    deeps = 1;
  }
  let _this = this
  while (_this.some(item => Array.isArray(item) && deeps > 0)) {
    _this = [].concat(..._this);
    deeps--;
  }
  return _this
}

// 递归
Array.prototype.myflat1 = function (deeps) {
  let _this = this
  if (deeps == undefined) {
    deeps = 1
  }
  if (deeps > 0) {
return_this.reduce((total, item) => {
      return total.concat(Array.isArray(item) ? item.flat(deeps - 1) : item)
    }, [])
  } else {
return_this
  }
}

let arr = [1, [2, 3, [4, 5], 6]]

function flatten(arr) {
  let res = []
  for (let i = 0; i < arr.length; i++) {
    const ele = arr[i]
    Array.isArray(ele) ? res=res.concat(flatten(ele)) : res.push(ele)
  }
  return res
}

console.log(flatten(arr));

let s = [1, 2, [1, 3, 4, [1, 1, 2]]]
console.log(s.myflat1(1))
```

#### 终止多重循环

```js
const arr = [
  {
    name: "张三",
    fruit: ["苹果", "香蕉"]
  },
  {
    name: "李四",
    fruit: ["梨", "芒果"]
  }
]

let personName
// for循环命名
loop1:
for (let index = 0; index < arr.length; index++) {
  loop2:
  for (let j = 0; j < arr[index].fruit.length; j++) {
    let fruit = arr[index].fruit[j];
    if (fruit === "芒果") {
      personName = arr[index].name
      console.log("person", personName)
      break loop1;
    }
  }
}
````

#### instanceof

```js
function my_instanceof(left, right) {
    while (true) {
        if (left.__proto__ === right.prototype) {
            return true;
        } else if (left.__proto__ === null) {
            return false;
        } else {
            left = left.__proto__;
        }
    }
}
let a = {}
let b = {}
console.log(my_instanceof(a, b))
```

#### new

```js
function _new(constructer, ...arg) {
    // 创建一个空的对象
    let resultObj = {};
    // 链接该对象到原型,这样新对象就能访问到原型上面的方法
    resultObj.__proto__ = constructer.prototype;
    // 然后实现步骤3，将新创建的对象作为this的上下文
    let result = constructer.call(resultObj, ...arg);
    // 实现步骤4：如果该函数没有返回对象（即result不是一个对象），则返回this（即resultObj)
    return typeof result === 'object' ? result : resultObj

    // 接下来就可以看看new的实现效果了
}

function Persion(name, age) {
    this.name = name;
    this.age = age;
}
let Persion1 = _new(Persion, 'lucy', '18');
let Persion2 = _new(Persion, 'chuan', '20');
console.log(Persion1.name); // 'lucy'
console.log(Persion2.name); // 'chuan'
console.log(Persion1 instanceof Persion); // true
console.log(Persion2 instanceof Persion); // true
```

#### 闭包和作用域

```js
// 解决输出0-9
for (var i = 0; i < 10; i++) {
  setTimeout(() => {
    console.log(i)
  }, 1000)
}

//局部变量
for(let i=0;i<10;i++){
    setTimeout(() => {
    console.log(i)
  }, 1000)
}


for (var i = 0; i < 10; i++) {
  ((i) => {
    setTimeout(() => {
      console.log(i)
    }, 1000);
  })(i)
}

// 使用闭包
function f1(n) {
  function f2() {
    console.log(n)
  }
  return f2
}

for (let i = 0; i < 10; i++) {
  let fun = f1(i)
  setTimeout(fun, 1000)
}

//setTimeout的第三个参数
for (var i = 0; i< 10; i++){
  setTimeout(((i) => {
    console.log(i);
    })(i), 1000)
}
//或者  
 for (var i = 0; i < 10; i++) {
  setTimeout(console.log, 1000, i)
}
```

#### vue全局事件总线

```js
class Bus {
  constructor() {
    this.bus = {}
  }

  on(name, fn) {
    if (!this.bus[name]) {
      this.bus[name] = fn
    } else {
      throw new Error(`${name} has been on`)
    }
  }

  emit(name, ...data) {
    if (this.bus[name]) {
      this.bus[name].apply(this, data)
      if (this.bus[name]._once === true) {
        this.off(name)
      }
    } else {
      throw new Error(`Can't find ${name}`)
    }
  }

  off(name) {
    // 判断是否全部删除
    if (name === undefined) {
      this.bus = {}
    } else {
      // 判断是否存在对应事件
      if (this.bus[name]) {
        delete this.bus[name]
      } else {
        throw new Error(`Can't find ${name}`)
      }
    }
  }

  once(name, fn) {
    if (!this.bus[name]) {
      this.bus[name] = fn
      // 增加只触发一次标志
      this.bus[name]._once = true
    } else {
      throw new Error(`${name} has been on`)
    }
  }
}
```

#### 发布者订阅模式

```js
//发布者与订阅模式:
var shoeObj = {};   // 定义发布者
shoeObj.list = [];  // 缓存列表 存放订阅者回调函数

// 增加订阅者:
shoeObj.listen = function(fn) {
    shoeObj.list.push(fn); // 订阅消息添加到缓存列表
}

// 发布消息:
shoeObj.trigger = function() {
        for (var i = 0, fn; fn = this.list[i++];) {
            fn.apply(this, arguments);//第一个参数只是改变fn的this,
        }
    }
 // 小红订阅如下消息:
shoeObj.listen(function(color, size) {
    console.log("颜色是：" + color);
    console.log("尺码是：" + size);
});

// 小花订阅如下消息:
shoeObj.listen(function(color, size) {
    console.log("再次打印颜色是：" + color);
    console.log("再次打印尺码是：" + size);
});
shoeObj.trigger("红色", 40);
shoeObj.trigger("黑色", 42);  
```

#### 函数柯里化

```js
function curry(fn) {
    return _curry.call(this, fn, fn.length);
}
function _curry(fn, len, ...args) {
    return function (...params) {
        const _args = args.concat(params);
        if (_args.length >= len) {
            return fn.apply(this, _args);
        } else {
            return _curry.call(this, fn, len, ..._args);
        }
    }
}
 // test
function add(a, b, c, d) {
    return a + b + c + d;
}
const addCurry = curry(add);
console.log(addCurry(1)(2)(3)(4)) // 10
console.log(addCurry(1, 2, 3)(4)) // 10
```

```js
// 实现一个add方法，使计算结果能够满足如下预期：
console.log(add(1)(2)(3)) // 6;
console.log(add(1, 2, 3)(4)) // 10;
console.log(add(1)(2)(3)(4)(5)) // 15;

function add() {
  let args = [...arguments];
  function _add() {
    args = args.concat([...arguments]);
    return _add;
  }
  _add.toString = function() {
    return args.reduce((pre, cur) => {
      return pre + cur;
    })
  }
  return _add;
}
```

```js
function curry(fn, ...args) {
    if (args.length >= fn.length) {
        return fn(...args)
    } else {
        return function (..._args) {
            return curry(fn, ..._args, ...args)
        }
    }
}
// test
function add(a, b, c, d) {
    return a + b + c + d;
}
const addCurry = curry(add);
console.log(addCurry(1)(2)(3)(4)) // 10
console.log(addCurry(1, 2, 3)(4)) // 10
```

#### 拷贝

深拷贝

```js
function dpClone(target, map = new Map()) {
    if (target.constructor === Date) {
        return new Date(target);
    }
    if (target.constructor === RegExp) {
        return new RegExp(target);
    }
    if (target instanceof Error) return new Error(target.message);
    if (target instanceof Function)
        return function proxy(...args) {
            return target.call(this, args);
        };
    if (typeof target != "object") return target;
    if (map.has(target)) return map.get(target);
    let newObj = new target.constructor();
    map.set(target, newObj);
    for (let key in target) {
        if (target.hasOwnProperty(key)) {
            newObj[key] = dp(target[key], map);
        }
    }
    return newObj;
};
```

```js
//对function会无法拷贝
let List = [
    { id: 1, name: "小红", age: 18 },
    { id: 2, name: "小明", age: 18 },
    { id: 3, name: "小红", age: 18 }
]

let newList = JSON.parse(JSON.stringify(List))
newList[1]["pat"] = "pig"
console.log(newList)
console.log(List)
```

```js
function deepClone(source) {
    const targetObj = source.constructor === Array ? [] : {}
    for (let key in source) {
        if (source.hasOwnProperty(key)) {
            if (source[key] && typeof source[key] === "object") {
                targetObj[key] = deepClone(source[key])
            } else {
                targetObj[key] = source[key]
            }
        }
    }
    return targetObj
}
```

**解构赋值针对一维数组和对象为深拷贝，多维数组和对象为浅拷贝**

#### setInterval

+ requestAnimationFrame实现

```js
const obj = {
    timer: null,
    setInterval: function (callback, interval) {
        const now = Date.now
        let startTime = now()
        let endTime = startTime
        const self = this
        const loop = function () {
            self.timer = requestAnimationFrame(loop)
            endTime = now()
            if (endTime - startTime >= interval) {
                startTime = endTime = now()
                callback && callback()
            }
        }
        this.timer = requestAnimationFrame(loop)
        return this.timer
    },
    clearInterval: function () {
        cancelAnimationFrame(this.timer)
    }
}
```

```js
let timer = null;
function interval(func, wait) {
    let interv = function () {
        func.call(null);
        timer = setTimeout(interv, wait);
    };
    timer = setTimeout(interv, wait);
}
if (timer) {
    window.clearSetTimeout(timer);
    timer = null;
}
```

+ setInterval 实现 setTimeout

```js
let time = null
function timeout(fn, delay) {
    time = setInterval(() => {
        fn.call(null);
        clearInterval(time)
    }, delay)
}

timeout(() => {
    console.log(1)
}, 400)
```

#### 手写函数AOP

> AOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计，安全控制，异常处理等。把这些功能抽离出来后，再通过动态织入的方式掺入业务逻辑模块中

```js
Function.prototype.before = function (beforeFn) {
  const self = this
  return function beforeFunc () {
    const args = arguments
    beforeFn.apply(this, args)
    return self.apply(this, args)
  }
}
Function.prototype.after = function (afterFn) {
  const self = this
  return function afterFunc () {
    const args = arguments
    const result = self.apply(this, args)
    afterFn.apply(this, args)
    return result
  }
}
function func () {
  console.log('2')
}
const newFunc = func.before(() => {
  console.log('1')
}).after(() => {
  console.log('3')
})
newFunc() // 1 2 3
```

#### dom转json

```js
function dom2Json(domtree) {
  let obj = {};
  obj.name = domtree.tagName;
  obj.children = [];
  domtree.childNodes.forEach((child) => obj.children.push(dom2Json(child)));
  return obj;
}

```

#### 实现对象的flatten方法

题目描述:

```js
const obj = {
 a: {
        b: 1,
        c: 2,
        d: {e: 5}
    },
 b: [1, 3, {a: 2, b: 3}],
 c: 3
}

flatten(obj) 结果返回如下
// {
//  'a.b': 1,
//  'a.c': 2,
//  'a.d.e': 5,
//  'b[0]': 1,
//  'b[1]': 3,
//  'b[2].a': 2,
//  'b[2].b': 3
//   c: 3
// }
```

实现代码如下:

```js
function isObject(val) {
  return typeof val === "object" && val !== null;
}

function flatten(obj) {
  if (!isObject(obj)) {
    return;
  }
  let res = {};
  const dfs = (cur, prefix) => {
    if (isObject(cur)) {
      if (Array.isArray(cur)) {
        cur.forEach((item, index) => {
          dfs(item, `${prefix}[${index}]`);
        });
      } else {
        for (let k in cur) {
          dfs(cur[k], `${prefix}${prefix ? "." : ""}${k}`);
        }
      }
    } else {
      res[prefix] = cur;
    }
  };
  dfs(obj, "");

  return res;
}
flatten();
```

#### 列表转成树形结构

题目描述:

```js
[
    {
        id: 1,
        text: '节点1',
        parentId: 0 //这里用0表示为顶级节点
    },
    {
        id: 2,
        text: '节点1_1',
        parentId: 1 //通过这个字段来确定子父级
    }
    ...
]

转成
[
    {
        id: 1,
        text: '节点1',
        parentId: 0,
        children: [
            {
                id:2,
                text: '节点1_1',
                parentId:1
            }
        ]
    }
]
```

实现代码如下:

```js
function listToTree(data) {
  let temp = {};
  let treeData = [];
  for (let i = 0; i < data.length; i++) {
    temp[data[i].id] = data[i];
  }
  for (let i in temp) {
    if (+temp[i].parentId != 0) {
      if (!temp[temp[i].parentId].children) {
        temp[temp[i].parentId].children = [];
      }
      temp[temp[i].parentId].children.push(temp[i]);
    } else {
      treeData.push(temp[i]);
    }
  }
  return treeData;
}
```

#### 大数相加

```js
function add(a ,b){
   //取两个数字的最大长度
   let maxLength = Math.max(a.length, b.length);
   //用0去补齐长度
   a = a.padStart(maxLength , 0);//"0009007199254740991"
   b = b.padStart(maxLength , 0);//"1234567899999999999"
   //定义加法过程中需要用到的变量
   let t = 0;
   let f = 0;   //"进位"
   let sum = "";
   for(let i=maxLength-1 ; i>=0 ; i--){
      t = parseInt(a[i]) + parseInt(b[i]) + f;
      f = Math.floor(t/10);
      sum = t%10 + sum;
   }
   if(f!==0){
      sum = '' + f + sum;
   }
   return sum;
}
```

#### Object.is

```js
function is (x, y) {
    if (x === y) {
        // 运行到1/x === 1/y的时候x和y都为0，但是1/+0 = +Infinity， 1/-0 = -Infinity, 是不一样的
        return x !== 0 || y !== 0 || 1 / x === 1 / y
    } else {
        // NaN===NaN是false,这是不对的，我们在这里做一个拦截，x !== x，那么一定是 NaN, y 同理
        // 两个都是NaN的时候返回true
        return x !== x && y !== y
    }
}
```

### 数据类型

+ 基本类型：在内存中占据固定大小，保存在栈内存中。
  + Number（数字）
  + String（字符串）
  + Boolean（布尔）
  + undefined（未定义）
  + null（空）
  + Symbol（符号）（ES6 新增的）
  + BigInt 大整数
+ 引用类型：引用类型的值是对象 保存在堆内存中，栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址。
  + Object（对象） 包括：数组、函数
  + Function（函数）
  + Array（数组）
  + Date（日期）
  + RegExp（正则表达式）
  + 特殊的基本包装类型（String、Number、Boolean）
  + 单体内置对象（Global、Math）...

#### 类型转换

`JavaScript`中，类型转换只有三种：

1. 转换成数字
2. 转换成布尔值
3. 转换成字符串

```js
console.log([]==![]); // true
```

![类型转换](../images/lxzh.png)

常用的！取反
! 一个感叹号是取反，首先将值转化为布尔类型的值，然后取反
!! 两个感叹号是将其他的数据类型转换为 boolean 类型，相当于Boolean()
转换规则：
判断一个值是真还是假，遵循：只有 0 NaN “” null undefined 这五个是假，其余的都是真
此处 数字0才为假，如果是字符串的’0’,为真

```javascript
console.log(!null) // true
console.log(!0) // true
console.log(!'0') // false
console.log(!undefined) //true
console.log(!"")) //true
```

判断两个值比较)是否相等，遵循：
如果是 == 比较的话，会进行默认的数据类型转换
1、对象 == 对象，永远不相等
2、对象 == 字符串 现将对象转换为字符串(调用toString的方法)，然后在进行比较

```javascript
 [] 转换为字符串 ""
 {} 转换为字符串 "[object Object]" 
  
 [] == "" 为 true
 {} == "" 为 false
 {} == "[object Object]"  为true
```

3、对象 == 布尔类型 对象先转为字符串(toString)，然后把字符串转换为数字(Number),布尔类型也转换为数字(true是1 false 是0)，最后让两个数字比较

```javascript
 console.log([] == false) // 为 true
 解析：首先 []转为字符串"",然后字符串转为数字类型number，Number("")结果为0，false
 转为数字类型，Number(false) 结果也为0，所以 [] == false, 就解析成了 0与0的比较，所以相等，
 返回true
 console.log({} == false) // 为 false
 解析：首先 {}转为字符串"[object Object]",然后字符串转为数字类型number，Number("[object Object]")结果为NaN，NaN 转为数字类型为NaN，NaN不等于任何值 返回false
```

4、对象 == 数字 对象先转为字符串(toString)，然后把字符串转换为数字(Number)
5、数字 == 布尔 布尔类型转换为数字
6、数字 == 字符串，字符串转换为数字
7、字符串 == 布尔 都转换为数字
8、null === undefined 结果是true
9、null和undefined 和其他任何数据类型都不相等

```javascript
console.log(null == 0) // false
console.log(undefined == 0) // false
```

#### 数据类型检测

#### 1、typeof

+ 优点：能够快速区分基本数据类型
+ 缺点：不能将Object、Array和Null区分，都返回object

#### 2、instanceof

+ 优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象
+ 缺点：Number，Boolean，String基本数据类型不能判断

#### 3、Object.prototype.toString.call()

+ 优点：精准判断数据类型
+ 缺点：写法繁琐不容易记，推荐进行封装后使用

### Array方法

| 方法名                | 作用                                                      | 返回值                                                       |
| --------------------- | --------------------------------------------------------- | ------------------------------------------------------------ |
| push()                | 从后面添加元素                                            | 添加之后的新数组的长度                                       |
| arr.unshift()         | 从前面添加元素                                            | 添加之后的新数组的长度                                       |
| arr.shift()           | 从前面删除元素，只能删一个                                | 删除的元素                                                   |
| arr.pop()             | 从后面删除元素，只能删一个                                | 删除的元素                                                   |
| arr.splice(i,n)       | 删除从 i (索引值)开始的 n 个元素                          | 删除的元素                                                   |
| str.split()           | 将字符串转化为数组                                        | 转化后的数组                                                 |
| arr.concat()          | 连接两个数组                                              | 连接后的新数组                                               |
| arr.reverse()         | 将数组反转                                                | 反转后的新数组                                               |
| arr.slice(start,end)  | 切去索引值 start 到索引值 end 的数组，不包含 end 索引的值 | 切出来的新数组                                               |
| arr.sort()            | 将数组进行排序                                            | 排序的数组（默认是按照最左边的数字进行排序，不是按照数字大小排序的） |
| arr.forEach(callback) | 遍历数组                                                  | 不管有无 return，都不会返回任何值，并且影响原数组            |
| arr.map(callback)     | 映射数组(遍历数组)                                        | 有 return 返回一个新数组                                     |
| arr.filter(callback)  | 过滤数组                                                  | 返回一个满足要求的数组                                       |

### 数组map，filter，reduce区别

**map：** `map`方法的作用是生成一个新数组(把原数组中的所有元素做一些变动，放进新数组中)

```js
callback
```

生成新数组元素的函数，使用三个参数：

+ `currentValue`

  `callback` 数组中正在处理的当前元素。

+ `index`可选

  `callback` 数组中正在处理的当前元素的索引。

+ `array`可选

  `map` 方法调用的数组。

`thisArg`可选

执行 `callback` 函数时值被用作`this`。

**filter：** `filter`方法的作用是从原数组中过滤出符合条件的元素，并生成一个新数组

```js
callback
```

用来测试数组的每个元素的函数。返回 `true` 表示该元素通过测试，保留该元素，`false` 则不保留。它接受以下三个参数：

+ `element`

  数组中当前正在处理的元素。

+ `index`可选

  正在处理的元素在数组中的索引。

+ `array`可选

  调用了 `filter` 的数组本身。

`thisArg`可选

执行 `callback` 时，用于 `this` 的值。

**reduce：** `reduce`方法的作用是通过回调函数的形式，把原数组中的元素最终转换成一个值，第一个参数是回调函数，第二个参数是初始值

```js
callbackFn
```

一个 “reducer” 函数，包含四个参数：

+ `previousValue`：上一次调用 `callbackFn` 时的返回值。在第一次调用时，若指定了初始值 `initialValue`，其值则为 `initialValue`，否则为数组索引为 0 的元素 `array[0]`。
+ `currentValue`：数组中正在处理的元素。在第一次调用时，若指定了初始值 `initialValue`，其值则为数组索引为 0 的元素 `array[0]`，否则为 `array[1]`。
+ `currentIndex`：数组中正在处理的元素的索引。若指定了初始值 `initialValue`，则起始索引号为 0，否则从索引 1 起始。
+ `array`：用于遍历的数组。

### forEach

使用匿名立即执行函数，相互独立不受影响，在forEach中使用setTimeout会失效

```js
const list = [1, 2, 3];
const square = num => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(num * num);
        }, 1000);
    })
}

/* function test() {
      list.forEach(async x => {
        const res = await square(x);
        console.log(res);
      });
    }
    test();//间隔一秒直接输出1，4，9
 */

//1.使用for循环
async function test() {
    for (let i = 0; i < list.length; i++) {
        let res = await square(list[i])
        console.log(res)
    }
}

// test()

// 2.for...of
async function test1() {
    for (let i of list) {
        const res = await square(i);
        console.log(res)
    }
}
// test1()

// 3.promise的then方法
let promise = Promise.resolve()
function test2(i) {
    if (i === list.length) return;
    promise = promise.then(async () => {
        const res = await square(list[i]);
        console.log(res)
    })
    test2(i + 1)
}
test2(0)
```

forEach(), filter(), reduce(), every() 和some()都会跳过空位。

map()会跳过空位，但会保留这个值。

join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。

### 立即执行函数

一个立即执行的函数表达式（IIFE），而且是一个具名的函数表达式（NFE）。在ECMAScript 标准中要求 NFE 实现两个特性

1. 只能在函数体内访问函数名变量。
2. 函数名变量可以理解为常量，不可改变。所以a = 20被忽略了，在严格模式下会报错

### sort

在V8引擎中

```js
// In-place QuickSort algorithm.
// For short (length <= 10) arrays, insertion sort is used for efficiency.
```

+ 数组长度小于等于10用插入排序，大于10使用快排

+ Mozilla的Firefox浏览器使用的是归并排序，归并排序是稳定的。
+ Safari浏览器使用的是桶排序和归并排序，如果参数中含有comparator函数就使用归并排序，没有的话就使用桶排序。桶排序的稳定性不确定，归并排序是稳定的。
+ IE浏览器使用的是不稳定的快速排序。

array. sort(sortFunction)是按照sortFunction结果大小排序。

### for循环和splice的坑

使用for循环遍历数组删除元素时会出现漏删的情况

```js
let arr=["a","a","a","b","e","f"];
for(let i=0;i<arr.length;i++){
 if(arr[i]==="a"){
  arr.splice(i,1);
 }
}
console.log(arr)//["a","b","e","f"]
```

原因：当数组长度改变时i继续改变会跳过其中的元素
解决方法：

1. 使用i--

```js
let arr=["a","a","a","b","e","f"];
for(let i=0;i<arr.length;i++){
 if(arr[i]==="a"){
  arr.splice(i,1);
 i--;
 }
}
console.log(arr)//["b","e","f"]
```

2.使用倒序删除(未处理的元素相对位置没变)

```js
let arr=["a","a","a","b","e","f"];
for(let i=arr.length-1;i>=0;i--){
 if(arr[i]==="a"){
  arr.splice(i,1);
 }
}
console.log(arr)//["b","e","f"]
```

**使用for...in...也会出现同样问题**

### 作用域

js 的作用域：就是代码名字（变量）在某个范围内起作用和效果。
目的：为了提高程序的可靠性，更重要的是减少命名冲突。

全局作用域： 整个script标签 或者是个单独的js文件

局部作用域（函数作用域）：在函数内就是局部作用域 这个代码的名字只在函数内部起效果和作用。

内部函数访问外部函数，采取链式查找的方式来决定取哪个值的结构。

全局变量和局部变量同名，全局变量不会作用于局部变量的作用域

### JSON.stringify

`JSON.stringify()`将值转换为相应的 JSON 格式：

+ 转换值如果有 toJSON() 方法，该方法定义什么值将被序列化。
+ 非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。
+ 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。
+ `undefined`、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 `null`（出现在数组中时）。函数、undefined 被单独转换时，会返回 undefined，如`JSON.stringify(function(){})` or `JSON.stringify(undefined)`.
+ 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。
+ 所有以 symbol 为属性键的属性都会被完全忽略掉，即便 `replacer` 参数中强制指定包含了它们。
+ Date 日期调用了 toJSON() 将其转换为了 string 字符串（同 Date.toISOString()），因此会被当做字符串处理。
+ NaN 和 Infinity 格式的数值及 null 都会被当做 null。
+ 其他类型的对象，包括 Map/Set/WeakMap/WeakSet，仅会序列化可枚举的属性。

### this指向

  1. 默认绑定规则 指向window 函数独立调用指向window

    全局函数严格模式执行undefined

  2. 隐式绑定规则 谁调用指向谁(隐式丢失 参数赋值)
  3. 立即执行函数指向window
  4. 显式绑定call,bind,apply 可以修改this指向(绑定失败会指向window)
  5. 函数作为参数时发生预编译，形参会赋值浅拷贝
  6. 父函数可以决定子函数的this指向 sort,reduce方法第三个参数可以修改this指向
  7. new操作指向实例对象可以this重写即return的返回的值为引用值
  8. new>显式绑定>隐私绑定>默认绑定
  9. 箭头函数的this 不能显式绑定改变this指向,隐式绑定无效,默认绑定无效,会指向外层最近的this(本身没有this)

    指定了严格模式('use strict'),this指向undefined

#### 函数内 this 指向

+ 普通函数调用 : window
+ 立即执行函数 : window
+ 定时器函数 : window
+ 事件绑定方法 : 绑定事件对象
+ 对象方法调用 : 该方法所属对象
+ 构造函数调用 : 实例对象 （原型对象里面的方法也指向实例对象）

#### 修改this指向

+ apply
+ bind
+ call

#### 相同点、不同点及应用场景

（1）相同点：都可以改变函数内部的 this 指向。

（2）不同点：

+ call 和 apply 会调用函数，并且改变函数内部 this 指向。
+ call 和 apply 传递的参数不一样，call 传递参数 aru1,aru2...形式，而 apply 必须数组形式[arg]。
+ bind 不会调用函数，但可以改变函数内部 this 指向。

（3）主要应用场景：

+ call 经常做继承。
+ apply 经常跟数组有关系，比如借助于数学对象实现数组最大值、最小值。
+ bind 不调用函数，但还想改变 this 指向时使用，比如改变定时器内部的 this 指向。

### 原型、原型链

<img src="./images/yxl.jpg" alt="原型链" style="zoom:50%;" />

### 伪数组和数组的区别？

得分点 类型是object、不能使用数组方法、可以获取长度、可以使用for in遍历 标准回答 伪数组它的类型不是Array，而是Object，而数组类型是Array。可以使用的length属性查看长度，也可以使用[index]获取某个元素，但是不能使用数组的其他方法，也不能改变长度，遍历使用for in方法。 伪数组的常见场景： -函数的参数arguments -原生js获取DOM：document.querySelector('div') 等 -jquery获取DOM：$(“div”)等

### new运算符

+ 在内存中创建一个新的空对象。
+ 设置原型，将对象的原型设置为函数的 prototype 对象。
+ 让 this 指向这个新对象，执行构造函数里面的代码（给这个新对象添加属性和方法）。
+ 判断函数的返回值类型，如：值类型，返回创建的对象，如：引用类型，就返回这个引用类型的对象。

```js
function _new(fn,..args){
    let obj=new Object(fn.prototype)
    let ret=fn.apply(obj,args)
    return ret instanceof Object ? ret:obj
}
```

**普通函数默认返回值为undefined，构造函数默认返回值为新创建的对象**

```js
//创建空对象
let obj=new Object()
//设置原型链
obj._proto_=Person.prototype
//改变this指向
let result=Person.call(obj)
//判断返回值类型
if(typeof result==="object"){
    person1=result
}else{
 person1=obj
}
```

#### 创建对象方法

+ 构造函数

+ new Object()
+ var obj2={}

### Object.create(null)和obj={}区别

Object.create(null) 创建出来的对象没有原型链

只保存值得情况下效率会比较高

### axios拦截器的原理

axios应用 请求拦截器是在发请求前同一队请求做处理，加上token或者时间戳， 响应拦截器会处理返回的结果，判断状态吗 原理：创建一个数组，数组中存dispatchRequest,把请求拦截器存在dispatchRequest前，用shift插入数组，响应拦截器存在dispatchRequest后，用push，期间为了保证运行的顺序，用队列的方式执行，用promise来保证运行的稳定

### parseInt

`console.log(parseInt("17", 6) === 1)//true`

+ parseInt可以传入两个参数，一个字符串，一个进制，当数不符合进制时只返回前一个符合的数

+ 参数2值在2~26之间，超过为`NaN`

+ Array.map()传三个参数（item,index,array），所以使用会出现

+ ```js
  ["1", "2", "3"].map(parseInt);//[1,NaN,NaN]
  ```

+ ```js
  //解决方法
  function returnInt(element) {
    return parseInt(element, 10);
  }
  
  ['1', '2', '3'].map(returnInt); // [1, 2, 3]
  // Actual result is an array of numbers (as expected)
  
  // Same as above, but using the concise arrow function syntax
  ['1', '2', '3'].map( str => parseInt(str) );
  
  // A simpler way to achieve the above, while avoiding the "gotcha":
  ['1', '2', '3'].map(Number); // [1, 2, 3]
  
  // But unlike parseInt(), Number() will also return a float or (resolved) exponential notation:
  ['1.1', '2.2e2', '3e300'].map(Number); // [1.1, 220, 3e+300]
  // For comparison, if we use parseInt() on the array above:
  ['1.1', '2.2e2', '3e300'].map( str => parseInt(str) ); // [1, 2, 3]
  ```

### 闭包

#### 1.闭包(closure)

指有权访问另一个函数作用域中变量的函数。

```js
function fn() {
    var num = 10;

    function fun() {
        console.log(num);
    }
    fun();

}
fn();
```

#### 2.闭包的特点

+ 函数嵌套函数。
+ 函数内部可以引用外部的参数和变量。
+ 参数和变量不会被垃圾回收机制回收。

#### 3.闭包的优点

+ 变量长期驻扎在内存中
+ 避免全局变量的污染
+ 私有成员的存在

#### 4.闭包的缺点

函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏。

#### 5.闭包的使用场景

+ 1.setTimeout：
  原生的setTimeout传递的第一个函数不能带参数，通过闭包可以实现传参效果；

```js
function f1(a) {
    function f2() {
        console.log(a);
    }
    return f2;
}
var fun = f1(1);
setTimeout(fun,1000);    //一秒之后打印出1
```

+ 2.回调：
  定义行为，然后把它关联到某个用户事件上（点击或者按键）。代码通常会作为一个回调（事件触发时调用的函数）绑定到事件。
+ 3.防抖函数：
  在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。
+ 4.封装私有变量：
  用js创建一个计数器：

```js
function f1() {
    var sum = 0;
    var obj = {
       inc:function () {
           sum++;
           return sum;
       }
};
    return obj;
}
let result = f1();
console.log(result.inc());  //1
console.log(result.inc());  //2
console.log(result.inc());  //3
```

### encodeURI 和encodeURIComponent

一般前端需要将uri编码两次，但在使用encodeURI编码时会出现保留字

| 类型         | 包含                                          |
| :----------- | :-------------------------------------------- |
| 保留字符     | `;` `,` `/` `?` `:` `@` `&` `=` `+` `$`       |
| 非转义的字符 | 字母 数字 `-` `_` `.` `!` `~` `*` `'` `(` `)` |
| 数字符号     | `#`                                           |

请注意，`encodeURI` 自身*无法*产生能适用于 HTTP GET 或 POST 请求的 URI，例如对于 XMLHTTPRequests，因为 "&", "+", 和 "=" 不会被编码，然而在 GET 和 POST 请求中它们是特殊字符。然而[`encodeURIComponent`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent)这个方法会对这些字符编码。

encodeURI 用来编码**URI**，其不会编码保留字符：;,/?😡&=+$

encodeURIComponent 用来编码 URI**参数**，除了字符：A-Z a-z 0-9 - _ . ! ~ * ' ( )，都将会转义

**escape方法已经被弃用**

### Promise

```js
const promise = new Promise((resolve, reject) => {
  console.log(1)
  resolve()
  console.log(2)
})

promise.then(() => {
  console.log(3)
})

console.log(4)
//  结果： 1 2 4 3 
// promise 构造函数是同步执行的，then 方法是异步执行的
// Promise new 的时候会立即执行里面的代码 
// then是微任务 会在本次任务执行完的时候执行，setTimeout是宏任务 会在下次任务执行的时候执行
```

#### promise 的三种状态

+ pending： 初始状态也叫等待状态
+ resolved/fulfiled： 成功状态
+ rejected： 失败状态

promise本身是同步的

promise的回调then里面的回调函数是异步的回调

```js
let a1=new Promise(()=>{
    setTimeout(()=>{
        console.log(1);
    },1000)
    console.log(2);
})
console.log(3);
//结果为2,3,1
```

#### 手写Promise

```js
//promise1.0
//
function myPromise(excutor) {
    //执行结构
    let self = this;
    //状态
    self.status = 'pending'
    self.value = null;//成功的值
    self.reason = null;//失败结果

    // 添加缓存数组
    self.onFulfilledCallbacks = []
    self.onRejectedCallbacks = []

    // 成功回调
    function resolve(value) {

        if (self.status === "pending") {
            // 保存成功结果
            self.value = value
            // 更改结果
            self.status = "fulfilled"
            // console.log('resolve', self.status);
            //状态改变，依次取出
            self.onFulfilledCallbacks.forEach(item => item(self.value))
        }
    }

    // 失败回调
    function reject(reason) {
        if (self.status === "pending") {
            // 保存失败结果
            self.reason = reason
            // 更改结果
            self.status = "rejected"
            // console.log('reject');
            self.onRejectedCallbacks.forEach(item => item(self.reason))
        }
    }

    try {
        excutor(resolve, reject)
    } catch (e) {
        reject(e)
    }
}

// then
myPromise.prototype.then = function (onFulfilled, onRejected) {
    // 固定this
    const self = this;
    // 状态改变=>调用then()方法
    onFulfilled = typeof onFulfilled === "function" ? onFulfilled : function (data) { resolve(data) }
    onRejected = typeof onRejected === "function" ? onRejected : function (err) { throw err }
    if (self.status === "pending") {
        self.onFulfilledCallbacks.push(onFulfilled)
        self.onRejectedCallbacks.push(onRejected)
    }
}

let demo = new myPromise((resolve, rejecct) => {
    console.log("1")
    setTimeout(() => {
        resolve(11)
    }, 2000)
})

// 异步失败
demo.then((res) => {
    console.log(res)
}, (err) => {
    console.log(err)
})

```

```js
function myPromise(excutor) {
    //执行结构
    let self = this;
    //状态
    self.status = 'pending'
    self.value = null;//成功的值
    self.reason = null;//失败结果

    // 添加缓存数组
    self.onFulfilledCallbacks = []
    self.onRejectedCallbacks = []

    // 成功回调
    function resolve(value) {

        if (self.status === "pending") {
            // 保存成功结果
            self.value = value
            // 更改结果
            self.status = "fulfilled"
            // console.log('resolve', self.status);
            //状态改变，依次取出
            self.onFulfilledCallbacks.forEach(item => item(self.value))
        }
    }

    // 失败回调
    function reject(reason) {
        if (self.status === "pending") {
            // 保存失败结果
            self.reason = reason
            // 更改结果
            self.status = "rejected"
            // console.log('reject');
            self.onRejectedCallbacks.forEach(item => item(self.reason))
        }
    }

    try {
        excutor(resolve, reject)
    } catch (e) {
        reject(e)
    }
}

// then
myPromise.prototype.then = function (onFulfilled, onRejected) {
    // 固定this
    const self = this;
    // 状态改变=>调用then()方法
    onFulfilled = typeof onFulfilled === "function" ? onFulfilled : function (data) { resolve(data) }
    onRejected = typeof onRejected === "function" ? onRejected : function (err) { throw err }
    /* if (self.status === "pending") {
      self.onFulfilledCallbacks.push(onFulfilled)
      self.onRejectedCallbacks.push(onRejected)
    } */

    if (self.status === "fulfilled") {
        return new myPromise((resolve, reject) => {
            try {
                let x = onFulfilled(self.value)
                x instanceof myPromise ? x.then(resolve, reject) : resolve(x)
            } catch (err) {
                reject(err)
            }
        })
    } else if (self.status === "rejected") {
        return new myPromise((resolve, reject) => {
            try {
                let x = onRejected(self.reason)
                x instanceof myPromise ? x.then(resolve, reject) : reject(x)
            } catch (err) {
                reject(err)
            }
        })
    }

    else {
        self.onFulfilledCallbacks.push(onFulfilled)
        self.onRejectedCallbacks.push(onRejected)
    }
}


myPromise.prototype.catch = function (fn) {
    return this.then(null, fn)
}

myPromise.resolve = function (value) {
    return new myPromise((resolve, reject) => {
        value instanceof myPromise ? value.then(resolve, reject) : resolve(value)
    })
}


myPromise.reject = function (reason) {
    return new myPromise((resolve, reject) => {
        reject(reason);
    });
}

/* let demo = new myPromise((resolve, rejecct) => {
    console.log("1")
    setTimeout(() => {
      resolve(11)
    }, 2000)
  })

  // 异步失败
  demo.then((res) => {
    console.log(res)
  }, (err) => {
    console.log(err)
  }) */

let isForget = true;
let getLv = new myPromise((resolve, reject) => {
    if (isForget) {
        let lv = {
            color: "orange",
            price: "￥99"
        }
        resolve(lv)
    } else {
        let err = new Error("我加班")
        reject(err)
    }
})

let buyLip = (lv) => {
    let lip = {
        brand: "尼玛",
        color: "pink"
    }

    let msg = {
        message: `我买的口红是${lip.brand}搭配的是${lv.color}`,
        lip: lip,
        lv: lv
    }

    return new myPromise(function (y, n) {
        y(msg)
    })
}

let testFn = () => {
    getLv
        .then(buyLip)
        .then((fulfilled) => {
        console.log(fulfilled)
    }).catch((rejected) => {
        console.log(rejected.message);
    })
}

testFn();

let p1 = new myPromise
.reject(2).then((res) => {
    console.log("res:" + res);
}, (err) => {
    console.log("err:" + err);
})
```

### promise.all和promise.race

```js
Promise.all = function (promises) {
    //存储所有成功结果
    //用来保存成功promise数量
    let resolveCount = 0;
    const values = new Array(promises.length);
    return new Promise((resolve, reject) => {
        //遍历获取每个promise的结果
        promises.forEach((p, index) => {
            Promise.resolve(p).then(
                (value) => {
                    resolveCount++; //成功数量加1
                    //p成功，将成功的value保存
                    values[index] = value;

                    //如果全部成功，将return的promise改为成功
                    if (resolveCount === promises.length) {
                        resolve(values);
                    }
                },
                (reason) => {
                    //只要有一个失败，return的promise就失败
                    reject(reason);
                }
            );
        });
    });
};
/* 
  promise函数对象的race方法
  返回一个promise，其结果由第一个完成的promise来决定
  */
Promise.race = function (promises) {
    return new Promise((resolve, reject) => {
        promises.forEach((p, index) => {
            Promise.resolve(p).then(
                (value) => {
                    resolve(value);
                },
                (reason) => {
                    reject(reason);
                }
            );
        });
    });
};
```

### JS常见的内存泄露

1.意外的全局变量
2.被遗忘的计时器或回调函数
3.脱离 DOM 的引用
4.闭包

### JS垃圾回收机制

**核心思想：找到没用的变量，释放它们的内存**

#### 回收策略

**（1）标记清除：**
标记清除是现在最常使用的垃圾回收策略, 使用标记清除作为垃圾回收机制的浏览器会在垃圾回收程序进行时会做如下几步 :

+ 标记内存中所有的变量。
+ 把在上下文（全局作用域，脚本作用域）中声明的变量，以及在全局被引用的变量的标记删除掉，剩下的所有带标记的变量就被视为要删除的变量，垃圾回收执行时释放它们占用的内存。
+ 内存清理，清除垃圾。

实例：

```js
// 变量 color，dog 在全局环境下声明，不会被清除
const color = 'red';
var dog = '金毛';
{
  let cat = 'kitty'; // 变量 cat 在块作用域中声明，且没有被全局所引用，所以会在下一次垃圾回收执行时，释放其内存
}
```

**（2）引用计数：**
引用计数是一种不常用的垃圾回收策略，主要核心思路就是记录值被引用的次数，一个值被赋给变量，引用次数+1，这个变量在某个时刻重新赋了一个新值，旧值的引用次数 -1 变为了0，在下次垃圾回收程序进行时就会释放它的内存。

**引用计数存在的问题：循环引用。**

实例：

```js
function fn() {
  const obj1 = new Object() 
  // new Object 在堆内存中创建了一个对象1 {} 这个值被赋值给obj1 于是引用次数 + 1
  const obj2 = new Object() 
  // new Object 在堆内存中创建了一个对象2 {} 这个值被赋值给obj2 于是引用次数 + 1

  obj1.a = obj2; // obj2 被赋值给 obj1的a属性  于是对象1的引用次数 1+1 = 2
  obj2.a = obj1; // obj1 被赋值给 obj2的a属性  于是对象2的引用次数 1+1 = 2
}
// 此时两个对象之间相互引用，如函数多次调用，又会重新执行多次函数体，又会多了n个相互引用的对象占用内存
```

```js
obj1.a = null; 
obj2.a = null; 
//  通过设置为 null 可以切断两者之间的引用，在下次回收时就会清理释放掉
```

### 事件流

事件流：事件流描述的是从页面中接收事件的顺序，DOM2 级事件流包括下面几个阶段：

+ 事件捕获阶段
+ 处于目标阶段
+ 事件冒泡阶段

addEventListener：addEventListener 是 DOM2 级事件新增的指定事件处理程序的操作，这个方法接收 3 个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序。

IE 只支持事件冒泡。

在浏览器中，事件的触发顺序一般而言依据：**捕获**->**目标阶段**->**冒泡**三个顺序

### 事件委托、事件源

事件委托：不在事件的发生地（直接 dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素 DOM 的类型，
来做出不同的响应。

举例：最经典的就是 ul 和 li 标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在 li 标签上直接添加，而是在 ul 父元素上添加。

**好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。**

Event.target 谁调用谁就是事件源。

target.nodeName返回大写标签名

### 事件冒泡

一个事件触发后，会在子元素和父元素之间传播，这种传播分为三个阶段：

+ 捕获阶段：（从 window 对象传导到目标节点（从外到里），这个阶段不会响应任何事件）。
+ 目标阶段：（在目标节点上触发）。
+ 冒泡阶段：（从目标节点传导回 window 对象（从里到外））。

事件委托/事件代理就是利用事件冒泡的机制把里层需要响应的事件绑定到外层。

### 取消请求

根据发送网络请求的 API 不同，取消方法不同

+ xhr
+ fetch
+ axios

如果使用`XMLHttpRequest`发送请求可以使用`XMLHttpRequest.abort()`

如果使用`fetch`发送请求可以使用`AbortController`

```text
const controller = new AbortController();
const signal = controller.signal;
fetch('https://somewhere', { signal })
controller.abort()
```

如果使用`axios`，取消原理同 fetch

```text
var CancelToken = axios.CancelToken;
var source = CancelToken.source();

axios.get('/https://somewhere', {
  cancelToken: source.token
}

source.cancel()
```

**xhr**

```js
const xhr = new XMLHttpRequest(),
  method = "GET",
  url = "https://developer.mozilla.org/";
xhr.open(method, url, true);

xhr.send();

// 取消发送请求
xhr.abort();
```

**fetch**

1. 发送请求时使用一个 `signal` 选项控制 fetch 请求
2. `control.abort()` 用以取消请求发送
3. 取消请求发送之后会得到异常 `AbortError`

```js
const controller = new AbortController()
const signal = controller.signal

const downloadBtn = document.querySelector('.download');
const abortBtn = document.querySelector('.abort');

downloadBtn.addEventListener('click', fetchVideo);

// 点击取消按钮时，取消请求的发送
abortBtn.addEventListener('click', function() {
  controller.abort();
  console.log('Download aborted');
});

function fetchVideo() {
  ...
  fetch(url, {signal}).then(function(response) {
    ...
  }).catch(function(e) {
   // 请求被取消之后将会得到一个 AbortError
    reports.textContent = 'Download error: ' + e.message;
  })
}
```

`Axios` 中通过 `cancelToken` 取消请求发送

```js
const CancelToken = axios.CancelToken;
const source = CancelToken.source();

axios
  .get("/user/12345", {
    cancelToken: source.token,
  })
  .catch(function (thrown) {
    if (axios.isCancel(thrown)) {
      console.log("Request canceled", thrown.message);
    } else {
      // handle error
    }
  });

axios.post(
  "/user/12345",
  {
    name: "new name",
  },
  {
    cancelToken: source.token,
  }
);

// cancel the request (the message parameter is optional)
source.cancel("Operation canceled by the user.");
```

### JSON数据转化成文件下载

```js
    function download(url, name) {
      const a = document.createElement("a");
      a.download = name;
      a.rel = "noopener";
      a.href = url;
      // 触发模拟点击
      a.dispatchEvent(new MouseEvent("click"));
      // 或者 a.click()
    }

    const json = {
      a: 3,
      b: 4,
      c: 5,
    };
    const str = JSON.stringify(json, null, 2);

    // 方案一：Text -> DataURL
    /* 
    方法一有 2 个缺点：
    1、无法保留缩进
    2、字符串里面的空格会被删除
    */
    const dataUrl = `data:,${str}`;
    download(dataUrl, "demo.json");

    // 方案二：Text -> Blob -> ObjectURL
    /* 
     Blob 的 API 是 var aBlob = new Blob( array, options );
    */
    const url = URL.createObjectURL(new Blob(str.split("")));
    download(url, "demo1.json");
```

### map和set

**Map结构：** 对象是创建无序键值对数据结构映射的主要机制，在ES6之前，对象的属性只能是字符串，在ES6之后，`Map`结构允许使用对象、数组等作为键。`Map`结构的方法或者属性如下：

+ `set()`：新增一个map结构的数据
+ `get(key)`：根据键获取值
+ `size`：获取map结构的长度
+ `delete(key)`：根据指定的键删除
+ `has(key)`：判断指定的键是否存在于map结构中
+ `keys()`遍历，`values()`遍历，`entries()`键值对遍历
+ `clear()`清空map结构

**Set结构：** `Set`是一个集合，它里面的值是唯一的，重复添加会被忽略(`Set`结构不允许强制类型转换，`1`和`"1"`被认为是两个不同的值)。`Set`结构的方法和属性如下：

+ `add()`：添加新值
+ `size`：获取`Set`结构的长度
+ `delete()`：根据指定的键删除
+ `has()`：判断指定的键是否存在`Set`集合中
+ `keys()`遍历、`values()`遍历、`entries()`遍历
+ `clear()`：清空`Set`结构

### 事件循环

`JavaScript`是单线程执行的，在`JavaScript`运行期间，有可能会阻塞UI渲染，这在一方面说明`JavaScript`引擎线程和UI渲染线程是互斥的。`JavaScript`被设计成单线程的原因在于，`JavaScript`可以修改DOM，如果在`JavaScript`工作期间，UI还在渲染的话，则可能不会正确渲染DOM。单线程也有一些好处，如下：

1. 节省内存空间
2. 节省上下文切换时间
3. 没有锁的问题存在

上面讲到函数会在执行栈中执行，那么当遇到异步代码后，该如何处理呢？其实当遇到异步代码的时候，会被挂起在Task队列中，一旦执行栈为空，就会从Task中拿出需要执行的代码执行，所以本质上讲JS中的异步还是同步行为。

![EventLoop](../images/sjxh.png) 如上图，可以看到，不同的异步任务是有区别的，异步任务又可以划分如下：

1. 宏任务(`script`、`setTimeout`、`setInterval`、`setImmidiate`、`I/O`、`UI Rendering`)可以有多个队列
2. 微任务(`procress.nextTick`、`Promise.then`、`Object.observe`、`mutataionObserver`)只能有一个队列

**执行顺序：** 当执行栈执行完毕后，会首先执行微任务队列，当微任务队列执行完毕再从宏任务中读取并执行，当再次遇到微任务时，放入微任务队列。

### Object 对象

+ `Object.keys`方法和`Object.getOwnPropertyNames`方法都用来遍历对象的属性。
+ `Object.getOwnPropertyDescriptor()`：获取某个属性的描述对象。
+ `Object.defineProperty()`：通过描述对象，定义某个属性。
+ `Object.defineProperties()`：通过描述对象，定义多个属性。
+ `Object.preventExtensions()`：防止对象扩展。
+ `Object.isExtensible()`：判断对象是否可扩展。
+ `Object.seal()`：禁止对象配置。
+ `Object.isSealed()`：判断一个对象是否可配置。
+ `Object.freeze()`：冻结一个对象。
+ `Object.isFrozen()`：判断一个对象是否被冻结。
+ `Object.create()`：该方法可以指定原型对象和属性，返回一个新的对象。
+ `Object.getPrototypeOf()`：获取对象的`Prototype`对象。
+ `Object.prototype.valueOf()`：返回当前对象对应的值。
+ `Object.prototype.toString()`：返回当前对象对应的字符串形式。
+ `Object.prototype.toLocaleString()`：返回当前对象对应的本地字符串形式。
+ `Object.prototype.hasOwnProperty()`：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。
+ `Object.prototype.isPrototypeOf()`：判断当前对象是否为另一个对象的原型。
+ `Object.prototype.propertyIsEnumerable()`：判断某个属性是否可枚举。

#### 对象描述属性

属性描述对象的各个属性称为“元属性”，因为它们可以看作是控制属性的属性。

```js
{
  value: 123,//属性值
  writable: false,//是否可改变
  enumerable: true,//是否可枚举
  configurable: false,//是否可配置
  get: undefined,//取值函数
  set: undefined//存值函数
}
```

#### Object.defineProperty

`Object.defineProperty`方法接受三个参数，依次如下。

+ object：属性所在的对象
+ propertyName：字符串，表示属性名
+ attributesObject：属性描述对象

### 对象合并

```js
const obj1 = { a: 1, b: 2 }
const obj2 = { b: 3, c: 4 }

// 1. Object.assign()

const result1 = Object.assign(obj1, obj2)
console.log(result1, obj1, obj2);
//会修改obj1,
// 同名属性覆盖，
// 第一个参数不为对象会转化为对象
// 除第一个参数，如果不为对象会转换，转换失败会直接忽略

// 2. 扩展运算符
const result2 = { ...obj1, ...obj2 }
console.log(result2, obj1, obj2);
// 同名属性覆盖，
// 对第一个参数无要求，转换失败会忽略
// 会修改obj1

// 3.使用库函数jquery.extend,lodash.assign,lodash.merge
```

### Dom

#### NodeType

`nodeType`属性值和对应的常量如下。

+ 文档节点（document）：9，对应常量`Node.DOCUMENT_NODE`
+ 元素节点（element）：1，对应常量`Node.ELEMENT_NODE`
+ 属性节点（attr）：2，对应常量`Node.ATTRIBUTE_NODE`
+ 文本节点（text）：3，对应常量`Node.TEXT_NODE`
+ 文档片断节点（DocumentFragment）：11，对应常量`Node.DOCUMENT_FRAGMENT_NODE`
+ 文档类型节点（DocumentType）：10，对应常量`Node.DOCUMENT_TYPE_NODE`
+ 注释节点（Comment）：8，对应常量`Node.COMMENT_NODE`

+ 属性
  + 属性
    + Node.prototype.nodeType
    + Node.prototype.nodeName
    + Node.prototype.nodeValue
    + Node.prototype.textContent
    + Node.prototype.baseURI
    + Node.prototype.ownerDocument
    + Node.prototype.nextSibling
    + Node.prototype.previousSibling
    + Node.prototype.parentNode
    + Node.prototype.parentElement
    + Node.prototype.firstChild，
    + Node.prototype.lastChild
    + Node.prototype.childNodes
    + Node.prototype.isConnected
  + 方法
    + Node.prototype.appendChild()
    + Node.prototype.hasChildNodes()
    + Node.prototype.cloneNode()
    + Node.prototype.insertBefore()
    + Node.prototype.removeChild()
    + Node.prototype.replaceChild()
    + Node.prototype.contains()
    + Node.prototype.compareDocumentPosition()
    + Node.prototype.isEqualNode()，
    + Node.prototype.isSameNode()
    + Node.prototype.normalize()
    + Node.prototype.getRootNode()

### EventTarget 接口

+ EventTarget.addEventListener()
  + `type`：事件名称，大小写敏感。
  + `listener`：监听函数。事件发生时，会调用该监听函数。
  + `useCapture`：布尔值，如果设为`true`，表示监听函数将在捕获阶段（capture）触发（参见后文《事件的传播》部分）。该参数可选，默认值为`false`（监听函数只在冒泡阶段被触发）。
+ EventTarget.removeEventListener()
+ EventTarget.dispatchEvent()

如果希望事件到某个节点为止，不再传播，可以使用事件对象的`stopPropagation`方法。但是，`stopPropagation`方法只会阻止事件的传播，不会阻止该事件触发`<p>`节点的其他`click`事件的监听函数。也就是说，不是彻底取消`click`事件。

如果想要彻底取消该事件，不再触发后面所有`click`的监听函数，可以使用`stopImmediatePropagation`方法。

### Event对象

+ 属性

  + Event.bubbles，Event.eventPhase

    + `Event.eventPhase`的返回值有四种可能。
      + 0，事件目前没有发生。
      + 1，事件目前处于捕获阶段，即处于从祖先节点向目标节点的传播过程中。
      + 2，事件到达目标节点，即`Event.target`属性指向的那个节点。
      + 3，事件处于冒泡阶段，即处于从目标节点向祖先节点的反向传播过程中。

  + Event.cancelable，Event.cancelBubble，Event.defaultPrevented

    + `Event.cancelable`属性返回一个布尔值，表示事件是否可以取消
    + 如果事件不能取消，调用`Event.preventDefault()`会没有任何效果。
    + `Event.cancelBubble`属性是一个布尔值，如果设为`true`，相当于执行`Event.stopPropagation()`，可以阻止事件的传播。
    + `Event.defaultPrevented`属性返回一个布尔值，表示该事件是否调用过`Event.preventDefault`方法。该属性只读。

  + Event.currentTarget，Event.target

    + `Event.currentTarget`属性返回事件当前所在的节点，即事件当前正在通过的节点，也就是当前正在执行的监听函数所在的那个节点。随着事件的传播，这个属性的值会变。

    + `Event.target`属性返回原始触发事件的那个节点，即事件最初发生的节点。这个属性不会随着事件的传播而改变。

  + Event.type

    + `Event.type`属性返回一个字符串，表示事件类型

  + Event.timeStamp

    + `Event.timeStamp`属性返回一个毫秒时间戳，表示事件发生的时间

  + Event.isTrusted

    + `Event.isTrusted`属性返回一个布尔值，表示该事件是否由真实的用户行为产生。

  + Event.detail

    + `Event.detail`属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息

+ 实例方法

  + Event.preventDefault()
    + `Event.preventDefault`方法取消浏览器对当前事件的默认行为。
  + Event.stopPropagation()
  + Event.stopImmediatePropagation()
  + Event.composedPath()
    + `Event.composedPath()`返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。

### addEventListener的第三个参数

options 可选

一个指定有关 `listener` 属性的可选参数**对象**。可用的选项如下：

+ `capture`: [`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean)，表示 `listener` 会在该类型的事件捕获阶段传播到该 `EventTarget` 时触发。
+ `once`: [`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean)，表示 `listener 在添加之后最多只调用一次。如果是` `true，` `listener` 会在其被调用之后自动移除。
+ `passive`: [`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean)，设置为 true 时，表示 `listener` 永远不会调用 `preventDefault()`。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。查看 [使用 passive 改善的滚屏性能](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#使用_passive_改善的滚屏性能) 了解更多。
+ `signal`：[`AbortSignal`](https://developer.mozilla.org/zh-CN/docs/Web/API/AbortSignal)，该 `AbortSignal` 的 [`abort()`](https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController/abort) 方法被调用时，监听器会被移除。

### Touch接口

[传送门](https://wangdoc.com/javascript/events/touch.html)

### ProgressEvent

`ProgressEvent`具有对应的实例属性。

+ `ProgressEvent.lengthComputable`
+ `ProgressEvent.loaded`
+ `ProgressEvent.total`

### with

with 语句的原本用意是为逐级的对象访问提供命名空间式的速写方式. 也就是在指定的代码区域, 直接通过节点名称调用对象。

如果想要改变 obj 中每一项的值，一般写法可能会是这样：

```javascript
// 重复写了3次的“obj”
obj.a = 2;
obj.b = 3;
obj.c = 4;
1234
```

而用了 with 的写法，会有一个简单的快捷方式

```javascript
with (obj) {
 a = 3;
 b = 4;
 c = 5;
}
```

缺点

+ 导致数据泄漏

+ 性能下降

需要明确with会创建一个新的作用域，由于box本身没有color这个变量，所以这个操作相当于往全局定义了一个值为red的全局变量，而不是在box对象中定义，因此可以全局访问color。

### argument

`arguments.callee`返回当前的函数对象

### delete

delete不能移除用var声明的变量

let和const声明的变量也不能被删除

+ delete只会在移除对象属性失败的情况下返回false，而这种情况只会发生在这个属性是一个不可设置的(Non-configurable)属性，
+ delete通常会在这个操作什么也不干的情况下（虽然第一条它也是什么都没干）返回true，或者在成功移除对象属性时返回true
+ delete操作只会在自身的属性上起作用，如果对象的原型链上有一个与待删除属性同名的属性，那么删除属性之后，对象会使用原型链上的那个属性

### 鼠标位置

+ e.x,e.clientX(鼠标到可视窗口左侧的距离)

+ e.pageX（鼠标得到页面左侧的距离）

+ e.screenX（鼠标到屏幕左侧的距离）

+ e.movementX（鼠标到上一次位置的横向距离）

+ e.offsetX（鼠标到目标元素`e.target`左侧的距离）

### 元素的尺寸

+ clientWidth、clientHeight（边框以内的尺寸，四舍五入的整数，不含滚动条）

+ offsetWidth、offsetHeight（包含边框，包含滚动条，四舍五入的整数）

+ scrollWidth、scrollHeight（内容尺寸，四舍五入的整数，不滚动时相当于clientWidth）

+ getBoundingClientRect()（最小矩形尺寸，含小数）

+ Window.innerWidth、Window.innerHeight

  只读的 [`Window`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window) 属性 **`innerWidth`** 返回以像素为单位的窗口的内部宽度。如果垂直滚动条存在，则这个属性将包括它的宽度。

### 导出pdf

插件：

+ html2canvas
+ jspdf

### 全屏

+ requestFullscreen()
+ mozRequestFullScreen()
+ msRequestFullScreen()
+ webkitRequestFullScreen()

### 判断是否mobile

```js
function isMobile() {
    return !!navigator.userAgent.match(
    /(iPhone|iPod|Android|ios|iOS|iPad|WebOS|Windows Phone|Phone|Backerry)/i
    )
}
console.log(isMobile())
```

### getComputedStyle

`Window.getComputedStyle()`方法返回一个对象，该对象在应用活动样式表并解析这些值可能包含的任何基本计算后报告元素的所有 CSS 属性的值。 私有的 CSS 属性值可以通过对象提供的 API 或通过简单地使用 CSS 属性名称进行索引来访问。

### let 与 var

var:

+ 变量提升
+ 没有局部作用域
+ 可重复声明，声明覆盖

### class

class的声明特征跟const和let类似，都是作用于块级作用域，预处理阶段则会屏蔽外部变量。因此在声明之前访问变量a都会报错，在声明之后访问才可以正常输出。

### for...of... 和for...in

`for...of` 只能遍历迭代器：Array,Map,Set,String,TypedArray,arguments

**`for...in`** 以任意顺序迭代一个对象的除Symbol以外的可枚举属性，包括继承的可枚举属性。

### includes 和 indexOf

+ includes返回Boolean
+ indexOf返回下标（-1为没有）
+ 第二个参数为起始位置可以为负值
+ NaN includes能匹配NaN，indexOf不能匹配NaN
+ undefined includes可以匹配稀疏数组 indexOf不能识别

### 字符串和数组的indexOf方法比较

不同点=>数据类型转换

+ 数组的indexOf方法在执行时使用严格相等
+ 字符串的indexOf方法会进行类型转换

### 字符串和数组的includes方法比较

不同点=>数据类型转换

+ 数组includes方法在执行时使用严格相等
+ 字符串的includes方法会进行类型转换

### 构造器

#### yield*

**`yield*` 表达式**用于委托给另一个[`generator`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*) 或可迭代对象。

#### yield

`yield` 关键字用来暂停和恢复一个生成器函数（([`function*`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*) 或[遗留的生成器函数 (en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Deprecated_and_obsolete_features)）。

### 图片懒加载

```js
let imgs = document.querySelectorAll("img")
let num = imgs.length
let n = 0
lazyload()
window.onscroll = lazyload;
function lazyload() {
    let seeHeight = document.documentElement.clientHeight;//可见区
    let scrollTop = document.documentElement.scrollTop || document.body.scrollTop
    for (let i = 0; i < num; i++) {
        if (imgs[i].offsetTop < scrollTop + seeHeight) {
            if (imgs[i].getAttribute("src") === "./imgs/loading.gif") {
                imgs[i].src = imgs[i].getAttribute("data-src");
            }
            n = n + 1
        }
    }
}
```

### null 和 undefined的区别

使用低位存储变量的类型信息，`000`开头代表对象，而`null`就代表全零，所以将它错误的判断成`Object`，虽然后期内部判断代码已经改变，但`null`类型为`object`的判断却保留了下来

+ 相似性
  + undefined==null
+ 不同
  + Number(undefined)=NaN
  + Number(null)=0
  + typeof undefind==="undefind"
  + typeof null==="object"
+ 出现undefined
  + 声明未赋值
  + 函数默认返回值
  + 对象缺失属性
  + 方法缺少实参

### 继承

在`JavaScript`ES6之前，实现继承需要依赖原型、原型链和构造函数等等技术手段组合使用，在ES6之后，可以使用`Class`类继承(并没有真正的类，只是一个语法糖，实质依然是函数)

继承的几种方式

1. 原型链实现继承
2. 借用构造函数实现继承
3. 组合继承
4. 寄生组合继承
5. 类继承

+ 原型链继承

```js
function Animal() {
  this.colors = ['red','blue'];
}
function Dog(name) {
  this.name = name;
}
Dog.prototype = new Animal();
```

+ 借用构造函数实现继承

```js
function Animal(name) {
  this.name = name;
  this.colors = ['red','blue'];
}
Animal.prototype.eat = function() {
  console.log(this.name + ' is eating!');
}
function Dog(name) {
  Animal.call(this,name);
}
```

+ 组合继承

```js
function Animal(name) {
  this.name = name;
  this.colors = ['red','blue'];
}
Animal.prototype.eat = function() {
  console.log(this.name + ' is eatting');
}
function Dog(name) {
  Animal.call(this,name);
}
```

+ 寄生组合继承

```js
function Animal(name) {
  this.name = name;
  this.colors = ['red','blue'];
}
Animal.prototype.eat = function() {
  console.log(this.name + ' is eatting');
}
function Dog(name) {
  Animal.call(this,name);
}
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;
```

+ Class实现继承

```js
class Animal {
  constructor(name) {
    this.name = name;
    this.colors = ['red','blue'];
  }
  eat() {
    console.log(this.name + ' is eatting');
  }
}
class Dog extends Animal {
  constructor(name) {
    super(name);
  }
}
```

### 类数组转数组

+ Array.from
+ Array.prototype.slice.call()
+ Array.prototype.forEach()进行属性遍历并组成新数组

### Promise、setTimeout、async

+ setTimeout属于宏任务
+ Promise本身是同步的立即执行函数，Promise.then属于微任务
+ async方法执行时，遇到await会立即执行表达式，表达式之后的代码放到微任务执行

### new Boolean和true、false

```js
let createdByNewBoolean= new Boolean(1);
let b=false
console.log(typeof createdByNewBoolean,typeof b)//object boolean
```

### 预编译

函数声明整体提升

变量 声明提升

四部曲

+ 创建AO对象（Activation Object (执行期上下文)）
+ 找形参和变量声明，将变量和形参名作为AO属性名，值为undefined
+ 将实参值与形参统一
+ 在函数体里面找函数声明，值赋予函数体

**预编译会打破if等判断声明变量但不能声明function**

在函数体中定义变量不使用var，let，const 会挂载到GO上

```js
function test(a, b) {
  console.log(a);
  c = 0;
  var c;a = 3;b = 2;
  console.log(b);
  function b(){}
  function d(){}
  console.log(b);
}
test(1);//1,2,2
```

### touch事件

click事件300ms延迟检测是否是dblclick

移动端新增touch事件

+ touchstart
+ touchmove
+ touchend
+ touchCancel（来电话时自动取消）

```js
document.addEventListener("touchstart", () => {
      console.log("touchstart")
    })
    document.addEventListener("touchmove", () => {
      console.log("touchmove")
    })
    document.addEventListener("touchend", () => {
      console.log("touchend")
    })
    document.addEventListener("touchcancel", () => {
      console.log("touchcancel")
    })

```

touchend和touchmove的target以touchstart的target为主

属性

+ touches （保存触点）
+ changedTouches（和当前事件相关的触点）
+ targetTouches （作用在当前元素上的触点）

#### 封装touch函数(playground仓库)

#### touch事件 穿透问题

## ES6

### let和const

##### 暂时性死区

只要块级作用域内存在`let`命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。

ES6 明确规定，如果区块中存在`let`和`const`命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。

总之，在代码块内，使用`let`命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。

```js
if (true) {
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
```

上面代码中，在`let`命令声明变量`tmp`之前，都属于变量`tmp`的“死区”。

“暂时性死区”也意味着`typeof`不再是一个百分之百安全的操作

#### 块级作用域需要的原因

第一种场景，内层变量可能会覆盖外层变量

第二种场景，用来计数的循环变量泄露为全局变量

### 顶层对象

+ 浏览器里面，顶层对象是`window`，但 Node 和 Web Worker 没有`window`。
+ 浏览器和 Web Worker 里面，`self`也指向顶层对象，但是 Node 没有`self`。
+ Node 里面，顶层对象是`global`，但其他环境都不支持。

```js
// 方法一
(typeof window !== 'undefined'
   ? window
   : (typeof process === 'object' &&
      typeof require === 'function' &&
      typeof global === 'object')
     ? global
     : this);

// 方法二
var getGlobal = function () {
  if (typeof self !== 'undefined') { return self; }
  if (typeof window !== 'undefined') { return window; }
  if (typeof global !== 'undefined') { return global; }
  throw new Error('unable to locate global object');
};
```

### 解构赋值

#### 数组

```js
let [a, b, c] = [1, 2, 3];

let [ , , third] = ["foo", "bar", "baz"];
third // "baz"

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]
```

不完全解构

```js
let [x, y] = [1, 2, 3];
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
```

如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。

对于 Set 结构，也可以使用数组的解构赋值。

#### 默认值

解构赋值允许指定默认值。

```js
let [foo = true] = [];
foo // true

let [x, y = 'b'] = ['a']; // x='a', y='b'
let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'
```

注意，ES6 内部使用严格相等运算符（`===`），判断一个位置是否有值。所以，只有当一个数组成员严格等于`undefined`，默认值才会生效。

默认值可以引用解构赋值的其他变量，但该变量必须已经声明。

```js
let [x = 1, y = x] = [];     // x=1; y=1
let [x = 1, y = x] = [2];    // x=2; y=2
let [x = 1, y = x] = [1, 2]; // x=1; y=2
let [x = y, y = 1] = [];     // ReferenceError: y is not defined
```

#### 对象

对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。

```js
let { bar, foo } = { foo: 'aaa', bar: 'bbb' };
foo // "aaa"
bar // "bbb"

let { baz } = { foo: 'aaa', bar: 'bbb' };
baz // undefined
```

如果解构失败，变量的值等于`undefined`。

```js
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"
foo // error: foo is not defined
```

对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。

```js
var {x = 3} = {x: undefined};
x // 3

var {x = 3} = {x: null};
x // null
```

属性`x`等于`null`，因为`null`与`undefined`不严格相等，所以是个有效的赋值，导致默认值`3`不会生效。

解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于`undefined`和`null`无法转为对象，所以对它们进行解构赋值，都会报错。

#### 用途

**交换变量的值**

```js
let x = 1;
let y = 2;

[x, y] = [y, x];
```

**从函数返回多个值**

函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。

**函数参数的定义**

解构赋值可以方便地将一组参数与变量名对应起来。

**提取 JSON 数据**

解构赋值对提取 JSON 对象中的数据，尤其有用。

**函数参数的默认值**

**遍历 Map 结构**

任何部署了 Iterator 接口的对象，都可以用`for...of`循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。

**输入模块的指定方法**

加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。

### 字符串扩展

ES6 加强了对 Unicode 的支持，允许采用`\uxxxx`形式表示一个字符，其中`xxxx`表示字符的 Unicode 码点。

但是，这种表示法只限于码点在`\u0000`~`\uFFFF`之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。

大括号表示法与四字节的 UTF-16 编码是等价的。

有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。

```js
'\z' === 'z'  // true
'\172' === 'z' // true
'\x7A' === 'z' // true
'\u007A' === 'z' // true
'\u{7A}' === 'z' // true
```

#### 遍历器接口

字符串可以被`for...of`循环遍历。

除了遍历字符串，这个遍历器最大的优点是可以识别大于`0xFFFF`的码点，传统的`for`循环无法识别这样的码点。

#### Unicode码支持

你可以直接在字符串里面输入这个汉字，也可以输入它的转义形式`\u4e2d`，两者是等价的。

但是，JavaScript 规定有5个字符，不能在字符串里面直接使用，只能使用转义形式。

+ U+005C：反斜杠（reverse solidus)
+ U+000D：回车（carriage return）
+ U+2028：行分隔符（line separator）
+ U+2029：段分隔符（paragraph separator）
+ U+000A：换行符（line feed）

这个规定本身没有问题，麻烦在于 JSON 格式允许字符串里面直接使用 U+2028（行分隔符）和 U+2029（段分隔符）。这样一来，服务器输出的 JSON 被`JSON.parse`解析，就有可能直接报错。JSON 格式已经冻结（RFC 7159），没法修改了。为了消除这个报错，[ES2019](https://github.com/tc39/proposal-json-superset) 允许 JavaScript 字符串直接输入 U+2028（行分隔符）和 U+2029（段分隔符）。

注意，模板字符串现在就允许直接输入这两个字符。另外，正则表达式依然不允许直接输入这两个字符，这是没有问题的，因为 JSON 本来就不允许直接包含正则表达式。

#### JSON.stringify()改造

 UTF-8 标准规定，`0xD800`到`0xDFFF`之间的码点，不能单独使用，必须配对使用。比如，`\uD834\uDF06`是两个码点，但是必须放在一起配对使用，代表字符`𝌆`。这是为了表示码点大于`0xFFFF`的字符的一种变通方法。单独使用`\uD834`和`\uDF06`这两个码点是不合法的，或者颠倒顺序也不行，因为`\uDF06\uD834`并没有对应的字符。

`JSON.stringify()`的问题在于，它可能返回`0xD800`到`0xDFFF`之间的单个码点。

#### 对象方法

##### String.fromCodePoint()

ES5 提供`String.fromCharCode()`方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于`0xFFFF`的字符。

##### String.raw()

ES6 还为原生的 String 对象，提供了一个`raw()`方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。

#### 实例

##### codePointAt()

JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为`2`个字节。对于那些需要`4`个字节储存的字符（Unicode 码点大于`0xFFFF`的字符），JavaScript 会认为它们是两个字符。

`charAt()`方法无法读取整个字符，`charCodeAt()`方法只能分别返回前两个字节和后两个字节的值。

`codePointAt()`方法返回的是码点的十进制值，如果想要十六进制的值，可以使用`toString()`方法转换一下。

##### normalize()

ES6 提供字符串实例的`normalize()`方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。

`normalize`方法可以接受一个参数来指定`normalize`的方式，参数的四个可选值如下。

+ `NFC`，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。
+ `NFD`，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。
+ `NFKC`，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，`normalize`方法不能识别中文。）
+ `NFKD`，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。

##### 查找字符

传统上，JavaScript 只有`indexOf`方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。

+ **includes()**：返回布尔值，表示是否找到了参数字符串。
+ **startsWith()**：返回布尔值，表示参数字符串是否在原字符串的头部。
+ **endsWith()**：返回布尔值，表示参数字符串是否在原字符串的尾部。

##### repeat()

`repeat`方法返回一个新字符串，表示将原字符串重复`n`次。

##### 补全

ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。`padStart()`用于头部补全，`padEnd()`用于尾部补全。当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。

##### 去空格

新增了`trimStart()`和`trimEnd()`这两个方法。它们的行为与`trim()`一致，`trimStart()`消除字符串头部的空格，`trimEnd()`消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。

##### matchAll

`matchAll()`方法返回一个正则表达式在当前字符串的所有匹配

##### replaceAll

引入了`replaceAll()`方法，可以一次性替换所有匹配。

**使用正则表达需要加g**

`replaceAll()`的第二个参数`replacement`是一个字符串，表示替换的文本，其中可以使用一些特殊字符串。

+ `$&`：匹配的字符串。
+ `$``：匹配结果前面的文本。
+ `$'`：匹配结果后面的文本。
+ `$n`：匹配成功的第`n`组内容，`n`是从1开始的自然数。这个参数生效的前提是，第一个参数必须是正则表达式。
+ `$$`：指代美元符号`$`。

`replaceAll()`的第二个参数`replacement`除了为字符串，也可以是一个函数，该函数的返回值将替换掉第一个参数`searchValue`匹配的文本。

##### at

`at()`方法接受一个整数作为参数，返回参数指定位置的字符，支持负索引（即倒数的位置）。

#### 正则扩展

##### Unicode字符表示法

ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上`u`修饰符，才能识别当中的大括号，否则会被解读为量词。

正则实例对象新增`unicode`属性，表示是否设置了`u`修饰符。

除了`u`修饰符，ES6 还为正则表达式添加了`y`修饰符，叫做“粘连”（sticky）修饰符。`y`修饰符的作用与`g`修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，`g`修饰符只要剩余位置中存在匹配就可，而`y`修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。

**lastIndex指定从何处开始匹配**

**match.index为匹配到的下标**

ES6 为正则表达式新增了`flags`属性，会返回正则表达式的修饰符。

```js
// ES5 的 source 属性
// 返回正则表达式的正文
/abc/ig.source
// "abc"

// ES6 的 flags 属性
// 返回正则表达式的修饰符
/abc/ig.flags
// 'gi'
```

##### 后行断言

“先行断言”指的是，`x`只有在`y`前面才匹配，必须写成`/x(?=y)/`。比如，只匹配百分号之前的数字，要写成`/\d+(?=%)/`。“先行否定断言”指的是，`x`只有不在`y`前面才匹配，必须写成`/x(?!y)/`。比如，只匹配不在百分号之前的数字，要写成`/\d+(?!%)/`。

“后行断言”正好与“先行断言”相反，`x`只有在`y`后面才匹配，必须写成`/(?<=y)x/`。比如，只匹配美元符号之后的数字，要写成`/(?<=\$)\d+/`。“后行否定断言”则与“先行否定断言”相反，`x`只有不在`y`后面才匹配，必须写成`/(?<!y)x/`。比如，只匹配不在美元符号后面的数字，要写成`/(?<!\$)\d+/`。

ES2018 引入了 Unicode 属性类，允许使用\p{...}和\P{...}（\P是\p的否定形式）代表一类 Unicode 字符，匹配满足条件的所有字符。

Unicode 属性类的标准形式，需要同时指定属性名和属性值。

```js
\p{UnicodePropertyName=UnicodePropertyValue}
```

但是，对于某些属性，可以只写属性名，或者只写属性值。

```js
\p{UnicodePropertyName}
\p{UnicodePropertyValue}
```

##### v修饰符

有时，需要向某个 Unicode 属性类添加或减少字符，即需要对属性类进行运算。现在有一个[提案](https://github.com/tc39/proposal-regexp-v-flag)，增加了 Unicode 属性类的运算功能。

它提供两种形式的运算，一种是差集运算（A 集合减去 B 集合），另一种是交集运算。

### 数值扩展

#### 二进制和八进制

ES6 提供了二进制和八进制数值的新的写法，分别用前缀`0b`（或`0B`）和`0o`（或`0O`）表示。

如果要将`0b`和`0o`前缀的字符串数值转为十进制，要使用`Number`方法。

#### 数值分隔符

ES2021，允许 JavaScript 的数值使用下划线（`_`）作为分隔符。

这个数值分隔符没有指定间隔的位数，也就是说，可以每三位添加一个分隔符，也可以每一位、每两位、每四位添加一个。

小数和科学计数法也可以使用数值分隔符。

数值分隔符有几个使用注意点。

+ 不能放在数值的最前面（leading）或最后面（trailing）。
+ 不能两个或两个以上的分隔符连在一起。
+ 小数点的前后不能有分隔符。
+ 科学计数法里面，表示指数的`e`或`E`前后不能有分隔符。

除了十进制，其他进制的数值也可以使用分隔符。

注意，分隔符不能紧跟着进制的前缀`0b`、`0B`、`0o`、`0O`、`0x`、`0X`。

下面三个将字符串转成数值的函数，不支持数值分隔符。主要原因是语言的设计者认为，数值分隔符主要是为了编码时书写数值的方便，而不是为了处理外部输入的数据。

+ Number()
+ parseInt()
+ parseFloat()

##### Number检测

ES6 在`Number`对象上，新提供了`Number.isFinite()`和`Number.isNaN()`两个方法。

`Number.isFinite()`用来检查一个数值是否为有限的（finite），即不是`Infinity`。

`Number.isNaN()`用来检查一个值是否为`NaN`。

`Number.isInteger()`用来判断一个数值是否为整数。

ES6 将全局方法`parseInt()`和`parseFloat()`，移植到`Number`对象上面，行为完全保持不变。

```js
Number.isInteger(3.0000000000000002) // true
```

上面代码中，`Number.isInteger`的参数明明不是整数，但是会返回`true`。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个`2`被丢弃了。

ES6 在`Number`对象上面，新增一个极小的常量`Number.EPSILON`。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。

对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的`1.00..001`，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。

`Number.EPSILON`实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。

#### 安全整数

JavaScript 能够准确表示的整数范围在`-2^53`到`2^53`之间（不含两个端点），超过这个范围，无法精确表示这个值。

ES6 引入了`Number.MAX_SAFE_INTEGER`和`Number.MIN_SAFE_INTEGER`这两个常量，用来表示这个范围的上下限。

`Number.isSafeInteger()`则是用来判断一个整数是否落在这个范围之内。

#### Math对象扩展

`Math.trunc`方法用于去除一个数的小数部分，返回整数部分。

对于非数值，`Math.trunc`内部使用`Number`方法将其先转为数值。

`Math.sign`方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。

它会返回五种值。

+ 参数为正数，返回`+1`；
+ 参数为负数，返回`-1`；
+ 参数为 0，返回`0`；
+ 参数为-0，返回`-0`;
+ 其他值，返回`NaN`。

`Math.cbrt()`方法用于计算一个数的立方根。

`Math.clz32()`方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。

对于小数，`Math.clz32`方法只考虑整数部分。

对于空值或其他类型的值，`Math.clz32`方法会将它们先转为数值，然后再计算。

`Math.imul`方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。

如果只考虑最后 32 位，大多数情况下，`Math.imul(a, b)`与`a * b`的结果是相同的，即该方法等同于`(a * b)|0`的效果（超过 32 位的部分溢出）。之所以需要部署这个方法，是因为 JavaScript 有精度限制，超过 2 的 53 次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，`Math.imul`方法可以返回正确的低位数值。

`Math.fround`方法返回一个数的32位单精度浮点数形式。

`Math.hypot`方法返回所有参数的平方和的平方根。

##### 对数方法

**（1） Math.expm1()**

`Math.expm1(x)`返回 ex - 1，即`Math.exp(x) - 1`。

**（2）Math.log1p()**

`Math.log1p(x)`方法返回`1 + x`的自然对数，即`Math.log(1 + x)`。如果`x`小于-1，返回`NaN`。

**（3）Math.log10()**

`Math.log10(x)`返回以 10 为底的`x`的对数。如果`x`小于 0，则返回 NaN。

**（4）Math.log2()**

`Math.log2(x)`返回以 2 为底的`x`的对数。如果`x`小于 0，则返回 NaN。

##### 双曲函数方法

ES6 新增了 6 个双曲函数方法。

+ `Math.sinh(x)` 返回`x`的双曲正弦（hyperbolic sine）
+ `Math.cosh(x)` 返回`x`的双曲余弦（hyperbolic cosine）
+ `Math.tanh(x)` 返回`x`的双曲正切（hyperbolic tangent）
+ `Math.asinh(x)` 返回`x`的反双曲正弦（inverse hyperbolic sine）
+ `Math.acosh(x)` 返回`x`的反双曲余弦（inverse hyperbolic cosine）
+ `Math.atanh(x)` 返回`x`的反双曲正切（inverse hyperbolic tangent）

#### BigInt

引入了一种新的数据类型 BigInt（大整数），来解决这个问题，这是 ECMAScript 的第八种数据类型。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。

为了与 Number 类型区别，BigInt 类型的数据必须添加后缀`n`。

```js
const a = 2172141653n;
const b = 15346349309n;

// BigInt 可以保持精度
console.log(a*b===33334444555566667777n)//true
```

BigInt 同样可以使用各种进制表示，都要加上后缀`n`。

BigInt 可以使用负号（`-`），但是不能使用正号（`+`），因为会与 asm.js 冲突。

`BigInt()`函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。参数如果是小数，也会报错

BigInt 继承了 Object 对象的两个实例方法。

+ `BigInt.prototype.toString()`
+ `BigInt.prototype.valueOf()`

它还继承了 Number 对象的一个实例方法。

+ `BigInt.prototype.toLocaleString()`

此外，还提供了三个静态方法。

+ `BigInt.asUintN(width, BigInt)`： 给定的 BigInt 转为 0 到 2width - 1 之间对应的值。
+ `BigInt.asIntN(width, BigInt)`：给定的 BigInt 转为 -2^width-1^ 到 2^width-1^ - 1 之间对应的值。
+ `BigInt.parseInt(string[, radix])`：近似于`Number.parseInt()`，将一个字符串转换成指定进制的 BigInt。

如果`BigInt.asIntN()`和`BigInt.asUintN()`指定的位数，小于数值本身的位数，那么头部的位将被舍弃。

数学运算方面，BigInt 类型的`+`、`-`、`*`和`**`这四个二元运算符，与 Number 类型的行为一致。除法运算`/`会舍去小数部分，返回一个整数。

BigInt 不能与普通数值进行混合运算。

BigInt 对应的布尔值，与 Number 类型一致，即`0n`会转为`false`，其他值转为`true`

比较运算符（比如`>`）和相等运算符（`==`）允许 BigInt 与其他类型的值混合计算，因为这样做不会损失精度。

BigInt 与字符串混合运算时，会先转为字符串，再进行运算。

### 函数扩展

#### 默认参数

```js
// 写法一
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}

// 写法二
function m2({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}

// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]

// x 和 y 都有值的情况
m1({x: 3, y: 8}) // [3, 8]
m2({x: 3, y: 8}) // [3, 8]

// x 有值，y 无值的情况
m1({x: 3}) // [3, 0]
m2({x: 3}) // [3, undefined]

// x 和 y 都无值的情况
m1({}) // [0, 0];
m2({}) // [undefined, undefined]

m1({z: 3}) // [0, 0]
m2({z: 3}) // [undefined, undefined]
```

通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。

函数的`length`属性，将返回没有指定默认值的参数个数,也就是说，指定了默认值后，`length`属性将失真。

```js
(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2
```

后文的 rest 参数也不会计入`length`属性

#### rest 参数

ES6 引入 rest 参数（形式为`...变量名`），用于获取函数的多余参数，这样就不需要使用`arguments`对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

#### name属性

函数的`name`属性，返回该函数的函数名。

#### 箭头函数

箭头函数有几个使用注意点。

（1）箭头函数没有自己的`this`对象（详见下文）。

（2）不可以当作构造函数，也就是说，不可以对箭头函数使用`new`命令，否则会抛出一个错误。

（3）不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

（4）不可以使用`yield`命令，因此箭头函数不能用作 Generator 函数。

箭头函数实际上可以让`this`指向固定化，绑定`this`使得它不再可变，这种特性很有利于封装回调函数。

除了`this`，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：`arguments`、`super`、`new.target`。

#### 尾调用

尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。

以下三种情况，都不属于尾调用。

```js
// 情况一
function f(x){
  let y = g(x);
  return y;
}

// 情况二
function f(x){
  return g(x) + 1;
}

// 情况三
function f(x){
  g(x);
}
```

`toString()`方法返回函数代码本身，以前会省略注释和空格。

修改后的`toString()`方法，明确要求返回一模一样的原始代码。

### 数组的扩展

#### 扩展运算符

扩展运算符（spread）是三个点（`...`）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。

**扩展运算符（`...`）内部使用`for...of`循环**

```js
[...'hello']
// [ "h", "e", "l", "l", "o" ]
```

上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。

```js
'x\uD83D\uDE80y'.length // 4
[...'x\uD83D\uDE80y'].length // 3
```

任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。

#### Array.from()

`Array.from()`方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）

#### Array.of()

`Array.of()`方法用于将一组值，转换为数组。

#### copyWithin()

数组实例的`copyWithin()`方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。

它接受三个参数。

+ target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
+ start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。
+ end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。

```js
// 将3号位复制到0号位
[1, 2, 3, 4, 5].copyWithin(0, 3, 4)
// [4, 2, 3, 4, 5]
```

#### 查找位置

数组实例的`find()`方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为`true`的成员，然后返回该成员。如果没有符合条件的成员，则返回`undefined`。

数组实例的`findIndex()`方法的用法与`find()`方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回`-1`。

`findLast()`和`findLastIndex()`，从数组的最后一个成员开始，依次向前检查，其他都保持不变。

#### fill

`fill`方法使用给定值，填充一个数组。

#### 遍历

ES6 提供三个新的方法——`entries()`，`keys()`和`values()`——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用`for...of`循环进行遍历，唯一的区别是`keys()`是对键名的遍历、`values()`是对键值的遍历，`entries()`是对键值对的遍历。

如果不使用`for...of`循环，可以手动调用遍历器对象的`next`方法，进行遍历。

```js
let letter = ['a', 'b', 'c'];
let entries = letter.entries();
console.log(entries.next().value); // [0, 'a']
console.log(entries.next().value); // [1, 'b']
console.log(entries.next().value); // [2, 'c']
```

#### includes（）

`Array.prototype.includes`方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的`includes`方法类似。

#### 扁平化

数组的成员有时还是数组，`Array.prototype.flat()`用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。

`flat()`默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将`flat()`方法的参数写成一个整数，表示想要拉平的层数，默认为1。

`flatMap()`方法对原数组的每个成员执行一个函数（相当于执行`Array.prototype.map()`），然后对返回值组成的数组执行`flat()`方法。该方法返回一个新数组，不改变原数组。

`flatMap()`只能展开一层数组。

#### at

`at()`方法，接受一个整数作为参数，返回对应位置的成员，并支持负索引。这个方法不仅可用于数组，也可用于字符串和类型数组

如果参数位置超出了数组范围，`at()`返回`undefined`。

#### 提案

很多数组的传统方法会改变原数组，比如`push()`、`pop()`、`shift()`、`unshift()`等等。数组只要调用了这些方法，它的值就变了。现在有一个[提案](https://github.com/tc39/proposal-change-array-by-copy)，允许对数组进行操作时，不改变原数组，而返回一个原数组的拷贝。

这样的方法一共有四个。

+ `Array.prototype.toReversed() -> Array`
+ `Array.prototype.toSorted(compareFn) -> Array`
+ `Array.prototype.toSpliced(start, deleteCount, ...items) -> Array`
+ `Array.prototype.with(index, value) -> Array`

它们分别对应数组的原有方法。

+ `toReversed()`对应`reverse()`，用来颠倒数组成员的位置。
+ `toSorted()`对应`sort()`，用来对数组成员排序。
+ `toSpliced()`对应`splice()`，用来在指定位置，删除指定数量的成员，并插入新成员。
+ `with(index, value)`对应`splice(index, 1, value)`，用来将指定位置的成员替换为新的值。

### 对象扩展

JavaScript 对象的属性分成两种：自身的属性和继承的属性。对象实例有一个`hasOwnProperty()`方法，可以判断某个属性是否为原生属性。ES2022 在`Object`对象上面新增了一个静态方法`Object.hasOwn()`，也可以判断是否为自身的属性。

`Object.hasOwn()`可以接受两个参数，第一个是所要判断的对象，第二个是属性名

#### 属性的遍历

ES6 一共有 5 种方法可以遍历对象的属性。

**（1）for...in**

`for...in`循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。

**（2）Object.keys(obj)**

`Object.keys`返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。

**（3）Object.getOwnPropertyNames(obj)**

`Object.getOwnPropertyNames`返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。

**（4）Object.getOwnPropertySymbols(obj)**

`Object.getOwnPropertySymbols`返回一个数组，包含对象自身的所有 Symbol 属性的键名。

**（5）Reflect.ownKeys(obj)**

`Reflect.ownKeys`返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。

以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。

+ 首先遍历所有数值键，按照数值升序排列。
+ 其次遍历所有字符串键，按照加入时间升序排列。
+ 最后遍历所有 Symbol 键，按照加入时间升序排列。

#### 扩展运算符

`...`

#### 解构赋值

对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。

#### 新方法

Object.is()
Object.assign()
Object.getOwnPropertyDescriptors()
__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()
Object.keys()，Object.values()，Object.entries()
Object.fromEntries()
Object.hasOwn()

##### Object.is()

ES5 比较两个值是否相等，只有两个运算符：相等运算符（`==`）和严格相等运算符（`===`）。它们都有缺点，前者会自动转换数据类型，后者的`NaN`不等于自身，以及`+0`等于`-0`。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。

ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。`Object.is`就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。

##### Object.assign()

`Object.assign()`方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。

`Object.assign()`方法的第一个参数是目标对象，后面的参数都是源对象。

注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。

如果该参数不是对象，则会先转成对象，然后返回。

由于`undefined`和`null`无法转成对象，所以如果它们作为参数，就会报错。

**`Object.assign()`方法实行的是浅拷贝，而不是深拷贝。**

`Object.assign()`可以用来处理数组，但是会把数组视为对象。

##### getOwnPropertyDescriptors()

ES5 的`Object.getOwnPropertyDescriptor()`方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了`Object.getOwnPropertyDescriptors()`方法，返回指定对象所有自身属性（非继承属性）的描述对象。

##### \_\_proto\_\_属性

JavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。

`Object.setPrototypeOf()`（写操作）、`Object.getPrototypeOf()`（读操作）、`Object.create()`（生成操作）代替。

##### Object.fromEntries()

`Object.fromEntries()`方法是`Object.entries()`的逆操作，用于将一个键值对数组转为对象。

### 运算符扩展

ES2016 新增了一个指数运算符（`**`）。

这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。

```js
// 相当于 2 ** (3 ** 2)
2 ** 3 ** 2
// 512
```

指数运算符可以与等号结合，形成一个新的赋值运算符（`**=`）。

#### 链判断运算符

```js
// 错误的写法
const  firstName = message.body.user.firstName || 'default';

// 正确的写法
const firstName = (message
  && message.body
  && message.body.user
  && message.body.user.firstName) || 'default';
```

#### 链判断符

三元运算符`?:`也常用于判断对象是否存在。

引入了“链判断运算符”（optional chaining operator）`?.`，简化上面的写法。

```js
const firstName = message?.body?.user?.firstName || 'default';
const fooValue = myForm.querySelector('input[name=foo]')?.value
```

链判断运算符`?.`有三种写法。

+ `obj?.prop` // 对象属性是否存在
+ `obj?.[expr]` // 同上
+ `func?.(...args)` // 函数或对象方法是否存在

```js
a?.b
// 等同于
a == null ? undefined : a.b

a?.[x]
// 等同于
a == null ? undefined : a[x]

a?.b()
// 等同于
a == null ? undefined : a.b()

a?.()
// 等同于
a == null ? undefined : a()
```

如果属性链有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响。

报错场合

以下写法是禁止的，会报错。

```js
// 构造函数
new a?.()
new a?.b()

// 链判断运算符的右侧有模板字符串
a?.`{b}`
a?.b`{c}`

// 链判断运算符的左侧是 super
super?.()
super?.foo

// 链运算符用于赋值运算符左侧
a?.b = c
```

右侧不得为十进制数值

为了保证兼容以前的代码，允许`foo?.3:0`被解析成`foo ? .3 : 0`，因此规定如果`?.`后面紧跟一个十进制数字，那么`?.`不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。

#### NULL运算符

ES2020 引入了一个新的 Null 判断运算符`??`。它的行为类似`||`，但是只有运算符左侧的值为`null`或`undefined`时，才会返回右侧的值。

现在的规则是，如果多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。

#### 逻辑运算符

这三个运算符`||=`、`&&=`、`??=`相当于先进行逻辑运算，然后根据运算结果，再视情况进行赋值运算。

它们的一个用途是，为变量或属性设置默认值。

### Symbol

ES6 引入了一种新的原始数据类型`Symbol`，表示独一无二的值。它属于 JavaScript 语言的原生数据类型之一，其他数据类型是：`undefined`、`null`、布尔值（Boolean）、字符串（String）、数值（Number）、大整数（BigInt）、对象（Object）。

Symbol 值通过`Symbol()`函数生成 **不使用new**

Symbol 值可以显式转为字符串，Symbol 值也可以转为布尔值，但是不能转为数值。

Symbol 值不能与其他类型的值进行运算，会报错。

ES2019提供了一个 Symbol 值的实例属性`description`，直接返回 Symbol 值的描述。

**注意，Symbol 值作为对象属性名时，不能用点运算符。**

```
let s = Symbol();

let obj = {
  [s]: function (arg) { ... }
};

obj[s](123);
```

上面代码中，如果`s`不放在方括号中，该属性的键名就是字符串`s`，而不是`s`所代表的那个 Symbol 值。

#### 魔术字符串

魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。

#### 属性名的遍历

Symbol 值作为属性名，遍历对象的时候，该属性不会出现在`for...in`、`for...of`循环中，也不会被`Object.keys()`、`Object.getOwnPropertyNames()`、`JSON.stringify()`返回。

但是，它也不是私有属性，有一个`Object.getOwnPropertySymbols()`方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。

#### Symbol.for()，Symbol.keyFor()

有时，我们希望重新使用同一个 Symbol 值，`Symbol.for()`方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。

`Symbol.for()`与`Symbol()`这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。

`Symbol.keyFor()`方法返回一个已登记的 Symbol 类型值的`key`。

[Symbol详解](https://wangdoc.com/es6/symbol.html)

### Set

ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。

这表明，在 Set 内部，两个`NaN`是相等的。另外，两个对象总是不相等的。

Set 结构的实例有以下属性。

+ `Set.prototype.constructor`：构造函数，默认就是`Set`函数。
+ `Set.prototype.size`：返回`Set`实例的成员总数。

Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。

+ `Set.prototype.add(value)`：添加某个值，返回 Set 结构本身。
+ `Set.prototype.delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。
+ `Set.prototype.has(value)`：返回一个布尔值，表示该值是否为`Set`的成员。
+ `Set.prototype.clear()`：清除所有成员，没有返回值。

Set 结构的实例有四个遍历方法，可以用于遍历成员。

+ `Set.prototype.keys()`：返回键名的遍历器
+ `Set.prototype.values()`：返回键值的遍历器
+ `Set.prototype.entries()`：返回键值对的遍历器
+ `Set.prototype.forEach()`：使用回调函数遍历每个成员

#### WeakSet

WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。

首先，WeakSet 的成员只能是对象，而不能是其他类型的值。

其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。

WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。

WeakSet 结构有以下三个方法。

+ **WeakSet.prototype.add(value)**：向 WeakSet 实例添加一个新成员。
+ **WeakSet.prototype.delete(value)**：清除 WeakSet 实例的指定成员。
+ **WeakSet.prototype.has(value)**：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。

### Map

JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。

ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。

**（1）size 属性**

`size`属性返回 Map 结构的成员总数。

**（2）Map.prototype.set(key, value)**

`set`方法设置键名`key`对应的键值为`value`，然后返回整个 Map 结构。如果`key`已经有值，则键值会被更新，否则就新生成该键。

**（3）Map.prototype.get(key)**

`get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`。

**（4）Map.prototype.has(key)**

`has`方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。

**（5）Map.prototype.delete(key)**

`delete`方法删除某个键，返回`true`。如果删除失败，返回`false`。

**（6）Map.prototype.clear()**

`clear`方法清除所有成员，没有返回值。

Map 结构原生提供三个遍历器生成函数和一个遍历方法。

+ `Map.prototype.keys()`：返回键名的遍历器。
+ `Map.prototype.values()`：返回键值的遍历器。
+ `Map.prototype.entries()`：返回所有成员的遍历器。
+ `Map.prototype.forEach()`：遍历 Map 的所有成员。

**需要特别注意的是，Map 的遍历顺序就是插入顺序。**

**Map 结构转为数组结构，比较快速的方法是使用扩展运算符（`...`）。**

### WeakMap

`WeakMap`结构与`Map`结构类似，也是用于生成键值对的集合。

首先，`WeakMap`只接受对象作为键名（`null`除外），不接受其他类型的值作为键名。

其次，`WeakMap`的键名所指向的对象，不计入垃圾回收机制。

`WeakMap`的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。

**注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。**

WeakMap 应用的典型场合就是 DOM 节点作为键名

WeakMap 的另一个用处是部署私有属性。

### WeakRef

提供了 WeakRef 对象，用于直接创建对象的弱引用。

```js
let target = {};
let wr = new WeakRef(target);
```

上面示例中，`target`是原始对象，构造函数`WeakRef()`创建了一个基于`target`的新对象`wr`。这里，`wr`就是一个 WeakRef 的实例，属于对`target`的弱引用，垃圾回收机制不会计入这个引用，也就是说，`wr`的引用不会妨碍原始对象`target`被垃圾回收机制清除。

WeakRef 实例对象有一个`deref()`方法，如果原始对象存在，该方法返回原始对象；如果原始对象已经被垃圾回收机制清除，该方法返回`undefined`。

### Proxy

Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。

ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。

```js
var proxy = new Proxy(target, handler);
```

Proxy 对象的所有用法，都是上面这种形式，不同的只是`handler`参数的写法。其中，`new Proxy()`表示生成一个`Proxy`实例，`target`参数表示所要拦截的目标对象，`handler`参数也是一个对象，用来定制拦截行为。

如果`handler`没有设置任何拦截，那就等同于直接通向原对象。

```js
var target = {};
var handler = {};
var proxy = new Proxy(target, handler);
proxy.a = 'b';
target.a // "b"
```

`handler`是一个空对象，没有任何拦截效果，访问`proxy`就等同于访问`target`。

一个技巧是将 Proxy 对象，设置到`object.proxy`属性，从而可以在`object`对象上调用。

```js
var object = { proxy: new Proxy(target, handler) };
```

### Reflecct

Reflect
Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers (en-US)的方法相同。Reflect不是一个函数对象，因此它是不可构造的。

描述
与大多数全局对象不同Reflect并非一个构造函数，所以不能通过new 运算符对其进行调用，或者将Reflect对象作为一个函数来调用。Reflect的所有属性和方法都是静态的（就像Math对象）。

Reflect 对象提供了以下静态方法，这些方法与proxy handler methods (en-US)的命名相同。

其中的一些方法与 Object 相同，尽管二者之间存在某些细微上的差别。

静态方法
Reflect.apply(target, thisArgument, argumentsList)
对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 Function.prototype.apply() 功能类似。

Reflect.construct(target, argumentsList[, newTarget])
对构造函数进行 new 操作，相当于执行 new target(...args)。

Reflect.defineProperty(target, propertyKey, attributes)
和 Object.defineProperty() 类似。如果设置成功就会返回 true

Reflect.deleteProperty(target, propertyKey)
作为函数的delete操作符，相当于执行 delete target[name]。

Reflect.get(target, propertyKey[, receiver])
获取对象身上某个属性的值，类似于 target[name]。

Reflect.getOwnPropertyDescriptor(target, propertyKey)
类似于 Object.getOwnPropertyDescriptor()。如果对象中存在该属性，则返回对应的属性描述符，否则返回 undefined。

Reflect.getPrototypeOf(target)
类似于 Object.getPrototypeOf()。

Reflect.has(target, propertyKey)
判断一个对象是否存在某个属性，和 in 运算符 的功能完全相同。

Reflect.isExtensible(target)
类似于 Object.isExtensible().

Reflect.ownKeys(target)
返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 Object.keys(), 但不会受enumerable 影响).

Reflect.preventExtensions(target)
类似于 Object.preventExtensions()。返回一个Boolean。

Reflect.set(target, propertyKey, value[, receiver])
将值分配给属性的函数。返回一个Boolean，如果更新成功，则返回true。

Reflect.setPrototypeOf(target, prototype)
设置对象原型的函数。返回一个 Boolean， 如果更新成功，则返回true。

## CSS技巧

### CSS选择器

#### CSS2 选择器

+ 标签选择器(div, h1, p)
+ id选择器(#myid)
+ 类选择器(.myclass)
+ 通配符选择器(*)
+ 后代选择器(li a)

#### CSS2 伪类选择器

+ 伪类选择器(a:link/visited/hover/active)

#### CSS3 选择器

空格 > +相邻兄弟选择器 ～ 通用选择器（查找后面所有）

#### 结构伪类选择器

+ 查找第几个：nth-child（n）
+ 查找同一类型第几个：nth-of-type
+ 查找唯一类型：only-of-type

#### 属性选择器

根据标签属性查找[attr-value]

+ :root 查找根元素 html 标签
+ :empty 查找空标签

#### 目标伪类选择器：（表单）

+ :enabled 查找可以使用的标签
+ :disabled 查找禁止使用的标签
+ :checked 查找被选中的标签

#### 伪元素选择器：:selection设置选中文本内容的高亮显示（只能用于背景和文本颜色）

+ 否定伪类选择器 not()
+ 语言伪类选择器 lang(取值)

#### 优先级（权重）

+ !important
+ 行内样式(1000) （在style属性里面写的样式）
+ id选择器(0100)#
+ 类选择器/属性选择器/伪类选择器(0010)
+ 标签选择器/伪元素选择器(0001)
+ 关系选择器/通配符选择器(0000)

**!important > ID选择器 > 类选择器=属性选择器=伪类选择器 > 标签选择器=伪元素选择器 > 通配符选择器**

样式表的来源不同时，优先级顺序为：
**内联样式 > 内部样式 > 外部样式 > 浏览器用户自定义样式 > 浏览器默认样式**

### 可以继承的元素

CSS 继承特性主要是文本方面

所有元素可继承：visibility 和 cursor。
块级元素可继承：text-indent 和 text-align。
列表元素可继承：list-style，list-style-type，list-style-position，list-style-image。
内联元素可继承：
letter-spacing（字体间距）
word-spacing（段落间距）
line-height（行高）
color（字体颜色）
font-family（字体种类）
font-size（字体大小）
font-style（字体样式）
font-variant（小型大写字母文本）
font-weight（字体粗细）
text-decoration（文本修饰）
text-transform（转换不同元素中的文本）
direction（文本方向）

### CSS盒模型

#### 标准盒模型

+ 标准盒模型：总宽度 = width+左右填充(padding)+左右边框(border)+左右外边距(margin)
  【width 指 content 部分的宽度】

#### 怪异盒模型

+ 怪异盒模型：总宽度 = width+左右外边距(margin)
  【width 指 边框 (border)+填充 (padding)+内容 (content) 部分的宽度】

#### 设置盒模型

```css
box-sizing:content-box;//标准盒模型

box-sizing:border-box;//怪异盒模型
```

### link和@import的区别

两者都是外部引用CSS的方式，它们的区别如下：

+ link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。
+ link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。
+ link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。
+ link支持使用Javascript控制DOM去改变样式；而@import不支持。

### li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？

浏览器会把inline内联元素间的空白字符（空格、换行、Tab等）渲染成一个空格。为了美观，通常是一个`<li>`放在一行，这导致`<li>`换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。

**解决办法：**

（1）为`<li>`设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。

（2）将所有`<li>`写在同一行。不足：代码不美观。

（3）将`<ul>`内的字符尺寸直接设为0，即font-size:0。不足：`<ul>`中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。

（4）消除`<ul>`的字符间隔letter-spacing:-8px，不足：这也设置了`<li>`内的字符间隔，因此需要将`<li>`内的字符间隔设为默认letter-spacing:normal。

### CSS定位（position）

#### 1、fixed

+ 脱离文档流，相对于浏览器可视区定位。

+ 不占据空间，和其他元素重叠。
+ 使用场景：浏览器页面滚动（不会移动）。

#### 2、relative

+ 不脱离文档流，相对于原来的位置定位。
+ 继续保留原来的位置，它会覆盖其他框

#### 3、absolute

+ 脱离文档流，相对于父级定位（拼爹型）。
+ 不占据空间，和其他元素重叠。
+ 父级有定位：以最近一级有定位父级为准定位。
+ 父级无定位或无父级：以 body 为准定位。

#### 4、static

+ 默认值，又称为静态定位，元素出现在正常的流中。

#### 5、sticky

+ 元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。元素定位表现在跨越特定阈值前为相对定位，之后为固定定位。

#### 6、inherit

+ 从父元素继承 position 属性的值。

### CSS清除浮动

#### 1、设置高度

给父元素单独定义高度。

+ 优点：快速简单、代码少。
+ 缺点：无法进行响应式布局

#### 2、空标签法

在浮动元素后面加一个空标签。

```css
.parent {
  clear: both;
  height: 0;
  overflow: hidden;
}

/* 很少使用这个方法 */
```

+ 优点：简单快速、代码少、兼容性高。
+ 缺点：增加空标签，不利于页面优化。

#### 3. 父级定义 overflow: hidden 属性法

```css
.parent {
  overflow: hidden;
  /* zoom: 1;   针对 IE6 的兼容 */
}
/* 很少用这种方式 */
```

+ 优点：简单快速、代码少、兼容性高。
+ 缺点：超出部分被隐藏，布局时要注意。

#### 4. ★万能清除法 :after

给塌陷的元素添加伪对象，类型一般用 clearfix。

```css
.clearfix: after {
  content: " ";         /* 内容为空 */
  height: 0;            /* 高度 0 */
  line-height: 0;       /* 行高为 0*/
  display: block;       /* 将文本转换为块级元素 */
  visibility: hidden;   /* 将元素隐藏 */
  clear: both;          /* 清除浮动 */
}

.clearfix {
  *zoom: 1;
/*  IE6、7 专用  */
}

/* ⚠️：★开发常用 */
```

+ 优点：写法固定、兼容性高。
+ 缺点：代码多

#### 5. 父级定义 overflow: auto 属性法

+ 优点：简单、代码少、兼容性好。
+ 缺点：内部宽高超过父级 div 时，会出现滚动条。

#### 6. 双伪元素法

（类型一般用：clearfix）

```css
.clearfix: before,
.clearfix: after {
  content: " ";
  display: block;
  clear: both;   
}

.clearfix {
  *zoom: 1;
}
/* ⚠️注意：很少用这种方式，改良版虽然比较简便，但是不严谨! */
```

### 水平垂直居中

#### 1.垂直居中

+ 纯文字类实现居中：

  ```css
  line-height: 跟盒子本身的高度相等;
  ```

#### 2.水平居中

+ 对于行内元素和文字：

  把 text-align: center; 给行内元素的父盒子。

  ```html
  <div class="box-a">
    <span>123</span>
  </div>
  ```

  ```css
  .box-a {
    text-align: center;  /* 只实现水平居中 */
  }
  ```

+ 对于确定宽度的块级元素：

  width 和 margin。

  width: 100px;

  margin: 0 auto;

  ```html
  <div class="box-b">123</div>
  ```

  ```css
  .box-b {
    width: 100px;
    margin: 0 auto;
  }
  ```

#### 3.水平垂直居中

+ 对于确定宽度的块级元素：

  + (1) 子绝父相 和 margin-left、margin-top
    position: relative;
    position: absolute;
    margin-left: (父width - 子width) / 2;
    margin-top: (父height - 子height) / 2;

  ```html
  <div class="box-a">
    <div class="box-b">123</div>
  </div>
  ```

  ```css
  .box-a {
    position: relative;
    width: 200px;
    height: 200px;
    background-color: green;
  }
  .box-b {
    position: absolute;
    width: 100px;
    height: 100px;
    margin-left: 50px;
    margin-top: 50px;
    background-color: yellow;
  }
  ```

  + (2) 子绝父相 和 left、top、-margin-left、 -margin-top(left、top都是宽高的一半)

  ```html
  <div class="box-c">
    <div class="box-d">123</div>
  </div>
  ```

  ```css
  .box-c {
    position: relative;
    width: 200px;
    height: 200px;
    background-color: green;
  }
  .box-d {
    position: absolute;
    width: 100px;
    height: 100px;
    left: 50%;   
    top: 50%;
    margin-left: -50px; /* 本身宽的一半 */    
    margin-top: -50px;  /* 本身高的一半 */
    background-color: yellow;
  }
  ```

+ 对于宽度未知的块级元素：

  + (1) 子绝父相 和 transform

    position: relative;

    position: absolute;

    left: 50%;

    top: 50%;

    transform: translate(-50%, -50%);

    ```html
    <div class="box-a">
      <div class="box-b">123</div>
    </div>
    ```

    ```css
    .box-a {
      position: relative;
      width: 400px;
      height: 400px;
      background-color: yellow;
    }
    .box-b {
      position: absolute;
      transform: translate(-50%, -50%); 
      width: 200px;
      height: 200px;
      left: 50%;   
      top: 50%;
      background-color: green;
    }
    ```

    + (2) flex 布局：
      display: flex;
      justify-content: center;
      align-items: center; 三个都给父盒子

    ```html
    <div class="box-c">
      <div class="box-d">123</div>
    </div>
    ```

    ```css
    .box-c {
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: yellow;
    }
    .box-d {
      background-color: green;
    }
    ```

### 隐藏元素

1. opacity：0; 该元素隐藏起来了，但不会改变页面布局，如果绑定 click 事件，点击该区域，能触发事件。
2. visibility：hidden; 该元素隐藏起来了，但不会改变页面布局，不会触发该元素绑定的事件 ，隐藏对应元素，在文档布局中仍保留原来的空间（重绘）。
3. display：none; 把元素隐藏起来，并且会改变页面布局。在文档布局中不再分配空间（回流+重绘）。

### 外边距重叠

两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。

两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。

两个外边距一正一负时，折叠结果是两者的相加的和。

### 回流和重绘

1）回流（Reflow）：引起 DOM 树结构变化，改变页面布局的过程。

（2）重绘（Repaint）：不影响页面布局，只跟样式有关的元素进行重新绘制的操作。

**! 注意：回流必引起重绘，而重绘不一定会引起回流。**

### 减少回流和重绘的方法

（1）CSS 中避免回流和重绘：

+ 尽量在 DOM 树的最末端改变 class
+ 避免设置多层内联样式
+ 动画效果应用到 position 设置为 absolute 或者 fixed 的元素上
+ 避免使用 table 布局
+ 使用 CSS3 硬件加速，可以让 transform、opacity、filters 等动画不会引起重绘

（2）JS 避免回流和重绘：

+ 避免使用 JS 一个样式修改完接着下一个样式，最好一次性更改 CSS 样式，或者将样式定义好 class
+ 避免频繁操作 DOM，使用文档片段创建子树，然后再拷贝到文档中
+ 先隐藏元素，进行修改后再显示该元素，因为 display:none 上的DOM操作不会引起回流和重绘
+ 避免循环读取 offsetleft 等属性，在循环之前把他们存起来
+ 对于复杂的动画效果，使用绝对定位让其脱离文档流，否则会引起父元素及后续元素大量回流

### BFC（块级格式上下文）

#### 概念

BFC 是 CSS 布局的一个概念，是一个独立的渲染区域，块级格式上下文。

#### 如何创建BFC？

+ 根元素，即 HTML 元素
+ float 的值不为 none
+ position 为 absolute 或 fixed
+ display 的值为 inline-block、table-cell、table-caption
+ overflow 的值不为 visible
+ 弹性布局flex

#### BFC的布局规则

1. 内部的元素会在垂直方向上一个接一个的放置；
2. Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻的Box的margin会发生重叠；
3. 生成BFC元素的子元素中，每一个子元素的margin与包含块的左边界border相接触（对于从左到右的格式化，否则相反），即使存在浮动也是如此；
4. BFC的区域不会与float元素区域重叠
5. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。
6. 计算BFC的高度时，浮动元素也参与计算

#### BFC的使用场景

+ 去除边距重叠现象（父元素变为BFC）
+ 解决包含塌陷（给子元素加margin可能会带着父元素一起跑）
+ 清除浮动（让父元素的高度包含子浮动元素）
+ 避免某元素被浮动元素覆盖
+ 避免多列布局由于宽度计算四舍五入而自动换行

### 画一条0.5px的线

采用 meta viewport 的方式：

```html
<meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
```

采用 border-image 的方式。
采用 transform: scale() 的方式。

### 过渡缩写包含的属性

+ transition-proprety： 过渡属性名
+ transition-duration： 完成过渡效果需要花费的时间
+ transition-timing-function： 指定切换效果的速度
+ transition-delay： 指定什么时候开始切换效果

### 动画缩写包含的属性

+ animation-name： 为@keyframes 动画名称
+ animation-duration： 动画需要花费的时间
+ animation-timing-function： 动画如何完成一个周期
+ animation-delay： 动画启动前的延迟间隔
+ animation-iteration-count： 动画播放次数
+ animation-direction： 是否轮流反向播放动画

### CSS3 动画和 JS 动画的差异性

渲染线程分为 main thread 和 compositor thread，如果 css 动画只改变 transform 和 opacity ，
这时整个 CSS 动画得以在 compositor trhead 完成（而 JS 动画则会在 main thread 执行， 然后出发 compositor thread 进行下一步操作），特别注意的是如果改变 transform 和 opacity 是不会 layout 或者 paint 的。

区别： 功能涵盖面，JS 比 CSS 大

实现/重构难度不一，CSS3 比 JS 更加简单，性能跳优方向固定对帧速表现不好的低版本浏览器，CSS3 可以做到自然降级

CSS 动画有天然事件支持 CSS3 有兼容性问题。

### CSS实现三角形

```html
<div></div>
/* 记忆口诀：盒子宽高均为零，三面边框皆透明 */
div:after {
  position: absolute;
  width: 0px;
  height: 0px;
  content: " ";
  border-right: 100px solid transparent;
  border-top: 100px solid #ff0;
  border-left: 100px solid transparent;
  border-bottom: 100px solid transparent;
}
```

### flex 元素上的属性

为了更好地控制 flex 元素，有三个属性可以作用于它们：

| 属性                                                         | 默认值 | 含义                                                         |
| ------------------------------------------------------------ | ------ | ------------------------------------------------------------ |
| [`flex-grow`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-grow) | 0      | flex-grow 属性⽤于设置或检索弹性盒⼦的扩展⽐率(放大比例)     |
| [`flex-shrink`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-shrink) | 1      | flex-shrink 属性指定了 flex 元素的收缩规则(缩小比例)         |
| [`flex-basis`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-basis) | auto   | flex-basis 属性⽤于设置或检索弹性盒伸缩基准值(计算项目是否有多余空间)默认值为项目自身大小 |

### box-shadow和text-shadow

box-shadow: h-shadow v-shadow blur spread color inset;

注意：boxShadow 属性把一个或多个下拉阴影添加到框上。该属性是一个用逗号分隔阴影的列表，每个阴影由 2-4 个长度值、一个可选的颜色值和一个可选的 inset 关键字来规定。省略长度的值是 0。

值说明

+ h-shadow必需的。水平阴影的位置。允许负值

+ v-shadow必需的。垂直阴影的位置。允许负值

+ blur可选。模糊距离

+ spread可选。阴影的大小

+ color可选。阴影的颜色。在CSS颜色值寻找颜色值的完整列表

+ inset可选。从外层的阴影（开始时）改变阴影内侧阴影

```css
h1 {
    font-size: 4rem;
    text-shadow: -1px 1px #eee,
        -2px 2px #eee,
        -3px 3px #eee,
        -4px 4px #eee,
        -5px 5px #eee,
        -6px 6px #eee;
}
```

可以设置多个shadow,会重叠实现立体效果。

### a 标签设置样式顺序

link->visited->hover->active

### padding 和margin的不同

相对不同，padding相对自身，margin相对父级元素

### 百分比与vw的区别

百分比相对于父元素，vw相对于页面可见区域宽度

### CSS新单位

+ vw视窗宽度的百分比（**1vw** 代表视窗的宽度为 **1%**）
+ vh视窗高度的百分比
+ vmin当前 **vw** 和 **vh 中较小的一个值**
+ vmax当前 **vw** 和 **vh 中较大的一个值**

### 行内元素和块级元素

块级元素独立一行，可以设置宽高，宽可继承父级宽度

行内元素宽高随内容改变

### 文字缩小

默认最小12px

```css
.size {
    font-size: 12px;
    transform: scale(0.4);
}
```

### grid布局

#### grid

grid 是一个 CSS 所有网格容器的简写属性，可以用来设置以下属性：

+ 显式网格属性： grid-template-rows、grid-template-columns 和 grid-template-areas。
+ 隐式网格属性： grid-auto-rows、grid-auto-columns 和 grid-auto-flow。
+ 间距属性： grid-column-gap 和 grid-row-gap。

网格元素

#### grid-column 属性

grid-column 属性定义了网格元素列的开始和结束位置。

 grid-column 是 grid-column-start 和 grid-column-end 属性的简写属性

#### grid-row 属性

grid-row 属性定义了网格元素行的开始和结束位置。

**注意：** grid-row 是 grid-row-start 和 grid-row-end 属性的简写属性

#### grid-area 属性

grid-area 属性是 grid-row-start, grid-column-start, grid-row-end 以及 grid-column-end 属性的简写。

#### 网格元素命名

grid-area 属性可以对网格元素进行命名。

命名的网格元素可以通过容器的 grid-template-areas 属性来引用

每行由单引号内 **' '** 定义，以空格分隔。

**.** 号表示没有名称的网格项。

### flex布局

以下6个属性设置在容器上。

> + flex-direction
> + flex-wrap
> + flex-flow
> + justify-content
> + align-items
> + align-content

#### flex-direction属性

flex-direction属性决定主轴的方向（即项目的排列方向）。

```css
.box {
  flex-direction: row | row-reverse | column | column-reverse;
}
```

可能有4个值。

> + row（默认值）：主轴为水平方向，起点在左端。
> + row-reverse：主轴为水平方向，起点在右端。
> + column：主轴为垂直方向，起点在上沿。
> + column-reverse：主轴为垂直方向，起点在下沿。

#### flex-wrap属性

默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行

```
.box{
  flex-wrap: nowrap | wrap | wrap-reverse;
}
```

它可能取三个值。

（1）nowrap（默认）：不换行。

（2）wrap：换行，第一行在上方。

（3）wrap-reverse：换行，第一行在下方。

#### flex-flow

flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。

#### justify-content属性

justify-content属性定义了项目在主轴上的对齐方式。

```css
.box {
  justify-content: flex-start | flex-end | center | space-between | space-around;
}
```

+ flex-start（默认值）：左对齐
+ flex-end：右对齐
+ center： 居中
+ space-between：两端对齐，项目之间的间隔都相等。
+ space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。

#### align-items属性

align-items属性定义项目在交叉轴上如何对齐。

```css
.box {
  align-items: flex-start | flex-end | center | baseline | stretch;
}
```

+ flex-start：交叉轴的起点对齐。
+ flex-end：交叉轴的终点对齐。
+ center：交叉轴的中点对齐。
+ baseline: 项目的第一行文字的基线对齐。
+ stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。

#### align-content属性

align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。

```css
.box {
  align-content: flex-start | flex-end | center | space-between | space-around | stretch;
}
```

#### 项目的属性

以下6个属性设置在项目上。

> + order
> + flex-grow
> + flex-shrink
> + flex-basis
> + flex
> + align-self

##### order属性

order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。

##### flex-grow属性

flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大

##### flex-shrink属性

flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。

##### lex-basis属性

flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。

##### flex属性

flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选

##### align-self属性

align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。

### 对 CSSSprites 的理解

CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。

**优点：**

+ 利用`CSS Sprites`能很好地减少网页的http请求，从而大大提高了页面的性能，这是`CSS Sprites`最大的优点；
+ `CSS Sprites`能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。

**缺点：**

+ 在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；
+ `CSSSprites`在开发的时候相对来说有点麻烦，需要借助`photoshop`或其他工具来对每个背景单元测量其准确的位置。
+ 维护方面：`CSS Sprites`在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的`CSS`，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动`CSS`

### 物理像素，逻辑像素，像素密度

以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px & 896px，也就是说当赋予一个 DIV元素宽度为 414px，这个 DIV 就会填满手机的宽度；

而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242/414=3，也就是说，在单边上，一个逻辑像素=3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏

```css
my-image { background: (low.png); }
@media only screen and (min-device-pixel-ratio: 1.5) {
  #my-image { background: (high.png); }
}
```

### z-index失效

z-index属性在下列情况下会失效：

+ 父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；
+ 元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；
+ 元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；

## HTML

### HTML5新增内容

+ 语义化标签
  + nav
  + header
  + footer
  + aside
  + content
  + main
  + article
  + section
  + figure(加载独立内容)上图下文
  + figcaption
  + video
  + audio
  + dialog(对话框)
  优点：
+ 没有css也能保持结构
+ 代码结构清晰
+ 有利于搜索引擎优化(SEO)
+ 例于开发维护

### 空元素

知名的空元素：

```html
<br><hr><img><input><link><meta>鲜为人知的是： <area><base><col><command> <embed><keygen><param><source><track><wbr>
```

### src和href

src和href都是**用来引用外部的资源**，它们的区别如下：

+ **src：** 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。
+ **href：** 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在a、link等标签上。

### video

video视频

```html
<video src='' poster='imgs/aa.jpg' controls></video>
```

属性：

+ poster：指定视频还没有完全下载完毕，或者用户还没有点击播放前显示的封面。默认显示当前视频文件的第一针画面，当然通过poster也可以自己指定。
+ controls 控制面板
+ width
+ height

### canvas和svg

+ 画布（canvas ）： canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。

```html
<canvas id="myCanvas" width="200" height="100"></canvas>
```

+ SVG：SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准

**（1）SVG：** SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。

其特点如下：

+ 不依赖分辨率
+ 支持事件处理器
+ 最适合带有大型渲染区域的应用程序（比如谷歌地图）
+ 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）
+ 不适合游戏应用

**（2）Canvas：** Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。

其特点如下：

+ 依赖分辨率
+ 不支持事件处理器
+ 弱的文本渲染能力
+ 能够以 .png 或 .jpg 格式保存结果图像
+ 最适合图像密集型的游戏，其中的许多对象会被频繁重绘

注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。

### img的srcset属性的作⽤？

响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。

### web worker

在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。

如何创建 web worker：

1. 检测浏览器对于 web worker 的支持性
2. 创建 web worker 文件（js，回传函数等）
3. 创建 web worker 对象

### 模块

```html
<script type="module">
</script>
```

### details

```html
<details>
    <summary>这是标题</summary>
    123
</details>
```

### datalist

```html
 <input type="url" list="url_list" name="link" />
<datalist id="url_list">
    <option label="W3School" value="http://www.W3School.com.cn" />
    <option label="Google" value="http://www.google.com" />
    <option label="Microsoft" value="http://www.microsoft.com" />
  </datalist>
```

#### video标签

```html
<video src=""></video>
```

属性：

|   属性   | 意思                                                         |
| :------: | ------------------------------------------------------------ |
| autoplay | 是否自动播放                                                 |
| controls | 是否显示控制条                                               |
|  poster  | 没有播放之前显示的展位图片                                   |
|   loop   | 是否循环播放                                                 |
| perload  | 预加载视频（缓存）与 autoplay 相冲突，设置了 autoplay 属性，perload 属性会失效 |

#### audio标签

```html
<audio>
  <source src="" type="">
</audio>
```

音频: 音频属性和视频属性差不多，不过宽高和 poster 属性不能用。muted 静音模式。

#### drag api

| 事件的主体 | 怎么触发   |                                    |
| ---------- | ---------- | ---------------------------------- |
| dragstart  | 被拖放元素 | 在开始拖放被拖放元素时触发         |
| darg       | 被拖放元素 | 在正在拖放被拖放元素时触发         |
| dragenter  | 目标元素   | 在被拖放元素进入某元素时触发       |
| dragover   | 目标元素   | 在被拖放在某元素内移动时触发       |
| dragleave  | 目标元素   | 在被拖放元素移出目标元素是触发     |
| drop       | 目标元素   | 在目标元素完全接受被拖放元素时触发 |
| dragend    | 被拖放元素 | 在整个拖放操作结束时触发           |

### html5元素

#### 新多媒体元素

| 标签                                                  | 描述                                                       |
| :---------------------------------------------------- | :--------------------------------------------------------- |
| [audio](https://www.runoob.com/tags/tag-audio.html)   | 定义音频内容                                               |
| [video](https://www.runoob.com/tags/tag-video.html)   | 定义视频（video 或者 movie）                               |
| [source](https://www.runoob.com/tags/tag-source.html) | 定义多媒体资源 <video> 和 <audio>                          |
| [embed](https://www.runoob.com/tags/tag-embed.html)   | 定义嵌入的内容，比如插件。                                 |
| [track](https://www.runoob.com/tags/tag-track.html)   | 为诸如 <video> 和 <audio> 元素之类的媒介规定外部文本轨道。 |

#### 新表单元素

| 标签                                                      | 描述                                                         |
| :-------------------------------------------------------- | :----------------------------------------------------------- |
| [datalist](https://www.runoob.com/tags/tag-datalist.html) | 定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。 |
| [keygen](https://www.runoob.com/tags/tag-keygen.html)     | 规定用于表单的密钥对生成器字段。                             |
| [output](https://www.runoob.com/tags/tag-output.html)     | 定义不同类型的输出，比如脚本的输出。                         |

#### 新的语义和结构元素

HTML5提供了新的元素来创建更好的页面结构：

| 标签                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [article](https://www.runoob.com/tags/tag-article.html)      | 定义页面独立的内容区域。                                     |
| [aside](https://www.runoob.com/tags/tag-aside.html)          | 定义页面的侧边栏内容。                                       |
| [bdi](https://www.runoob.com/tags/tag-bdi.html)              | 允许您设置一段文本，使其脱离其父元素的文本方向设置。         |
| [command](https://www.runoob.com/tags/tag-command.html)      | 定义命令按钮，比如单选按钮、复选框或按钮                     |
| [details](https://www.runoob.com/tags/tag-details.html)      | 用于描述文档或文档某个部分的细节                             |
| [dialog](https://www.runoob.com/tags/tag-dialog.html)        | 定义对话框，比如提示框                                       |
| [summary](https://www.runoob.com/tags/tag-summary.html)      | 标签包含 details 元素的标题                                  |
| [figure](https://www.runoob.com/tags/tag-figure.html)        | 规定独立的流内容（图像、图表、照片、代码等等）。             |
| [figcaption](https://www.runoob.com/tags/tag-figcaption.html) | 定义 <figure> 元素的标题                                     |
| [footer](https://www.runoob.com/tags/tag-footer.html)        | 定义 section 或 document 的页脚。                            |
| [header](https://www.runoob.com/tags/tag-header.html)        | 定义了文档的头部区域                                         |
| [mark](https://www.runoob.com/tags/tag-mark.html)            | 定义带有记号的文本。                                         |
| [meter](https://www.runoob.com/tags/tag-meter.html)          | 定义度量衡。仅用于已知最大和最小值的度量。                   |
| [nav](https://www.runoob.com/tags/tag-nav.html)              | 定义导航链接的部分。                                         |
| [progress](https://www.runoob.com/tags/tag-progress.html)    | 定义任何类型的任务的进度。                                   |
| [ruby](https://www.runoob.com/tags/tag-ruby.html)            | 定义 ruby 注释（中文注音或字符）。                           |
| [rt](https://www.runoob.com/tags/tag-rt.html)                | 定义字符（中文注音或字符）的解释或发音。                     |
| [rp](https://www.runoob.com/tags/tag-rp.html)                | 在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容。 |
| [section](https://www.runoob.com/tags/tag-section.html)      | 定义文档中的节（section、区段）。                            |
| [time](https://www.runoob.com/tags/tag-time.html)            | 定义日期或时间。                                             |
| [wbr](https://www.runoob.com/tags/tag-wbr.html)              | 规定在文本中的何处适合添加换行符。                           |

#### 已移除的元素

以下的 HTML 4.01 元素在HTML5中已经被删除:

+ `<acronym>`
+ `<applet>`
+ `<basefont>`
+ `<big>`
+ `<center>`
+ `<dir>`
+ `<font>`
+ `<frame>`
+ `<frameset>`
+ `<noframes>`
+ `<strike>`
+ `<tt>`

### 块内、行内、行内块元素及转换

#### 1、块级元素

独占一行，高、宽、内外边距可控制

```html
<h1>~<h6>、<p>、<div>、<ul>、<ol>、<li>
```

#### 2、行内元素

一行可显示多个，高宽设置无效，水平方向的内外边距有效，垂直方向的内外边距无效。

```html
<a>、<strong>、<b>、<em>、<i>、<del>、<s>、<ins>、<u>、<span>
```

#### 3、行内块

一行可显示多个（行内特点），宽、高、内外边距可控制（块特点）。

```html
<img/>、<input/>、<td>、<button>
```

#### 4、转换

```css
.block{
 display:block;
}

.inline{
    display:inline;
}

.inline-block{
 display:inline-block;
}
```

### Doctype 的作用

Doctype 声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。

+ 严格模式：排版和 JS 运作模式是以该浏览器支持的最高标准运行。
+ 混杂模式：向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。

#### HTML5唯一doctype

```html
<!DOCTYPE html>
```

#### HTML4 Strict

```html
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
```

#### HTML 4.01 Transitional

这个 DTD 包含所有 HTML 元素和属性，包括表象或过时的元素（如 font ）。框架集是不允许的。

```html
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
```

#### HTML 4.01 Frameset

这个 DTD 与 HTML 4.01 Transitional 相同，但是允许使用框架集内容。

```html
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">
```

#### XHTML 1.0 Strict

这个 DTD 包含所有 HTML 元素和属性，但不包括表象或过时的元素（如 font ）。框架集是不允许的。结构必须按标准格式的 XML 进行书写。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
```

#### XHTML 1.0 Transitional

这个 DTD 包含所有 HTML 元素和属性，包括表象或过时的元素（如 font ）。框架集是不允许的。结构必须按标准格式的 XML 进行书写。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
```

#### XHTML 1.0 Frameset

这个 DTD 与 XHTML 1.0 Transitional 相同，但是允许使用框架集内容。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
```

#### XHTML 1.1

这个 DTD 与 XHTML 1.0 Strict 相同，但是允许您添加模块（例如为东亚语言提供 ruby 支持）。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
```

### navigator

#### Navigator 对象属性

| 属性                                                         | 说明                                        |
| :----------------------------------------------------------- | :------------------------------------------ |
| [appCodeName](https://www.runoob.com/jsref/prop-nav-appcodename.html) | 返回浏览器的代码名                          |
| [appName](https://www.runoob.com/jsref/prop-nav-appname.html) | 返回浏览器的名称                            |
| [appVersion](https://www.runoob.com/jsref/prop-nav-appversion.html) | 返回浏览器的平台和版本信息                  |
| [cookieEnabled](https://www.runoob.com/jsref/prop-nav-cookieenabled.html) | 返回指明浏览器中是否启用 cookie 的布尔值    |
| [platform](https://www.runoob.com/jsref/prop-nav-platform.html) | 返回运行浏览器的操作系统平台                |
| [userAgent](https://www.runoob.com/jsref/prop-nav-useragent.html) | 返回由客户机发送服务器的user-agent 头部的值 |

#### 方法

| 方法                                                         | 描述                                      |
| :----------------------------------------------------------- | :---------------------------------------- |
| [javaEnabled()](https://www.runoob.com/jsref/met-nav-javaenabled.html) | 指定是否在浏览器中启用Java                |
| [taintEnabled()](https://www.runoob.com/jsref/met-nav-taintenabled.html) | 规定浏览器是否启用数据污点(data tainting) |

### Screen 对象属性

| 属性                                                         | 说明                                     |
| :----------------------------------------------------------- | :--------------------------------------- |
| [availHeight](https://www.runoob.com/jsref/prop-screen-availheight.html) | 返回屏幕的高度（不包括Windows任务栏）    |
| [availWidth](https://www.runoob.com/jsref/prop-screen-availwidth.html) | 返回屏幕的宽度（不包括Windows任务栏）    |
| [colorDepth](https://www.runoob.com/jsref/prop-screen-colordepth.html) | 返回目标设备或缓冲器上的调色板的比特深度 |
| [height](https://www.runoob.com/jsref/prop-screen-height.html) | 返回屏幕的总高度                         |
| [pixelDepth](https://www.runoob.com/jsref/prop-screen-pixeldepth.html) | 返回屏幕的颜色分辨率（每象素的位数）     |
| [width](https://www.runoob.com/jsref/prop-screen-width.html) | 返回屏幕的总宽度                         |

### html保留字符输出

| Character | Entity |
| :-------- | :----- |
| &         | `&`    |
| <         | `<`    |
| >         | `>`    |
| "         | `"`    |

### 实现剪切板操作

旧法

+ `document.execCommand('copy')`
+ `document.execCommand('cut')`
+ `document.execCommand('paste')`

新法

`navigator.clipboard` 属性返回 Clipboard 对象，所有操作都通过这个对象进行

如果`navigator.clipboard`属性返回`undefined`，就说明当前浏览器不支持这个 API

+ `read()` 从剪贴板读取数据（比如图片），返回一个 Promise对象。
+ `readText()` 从操作系统读取文本，返回一个 Promise对象。
+ `write()` 写入任意数据至操作系统剪贴板。
+ `writeText()` 写入文本至操作系统剪贴板。

```js
function copy() {
    let copy = navigator.clipboard
    if (copy) {
        copy.writeText("ljk")
        alert("success")
    }
}
```

### input 的type

#### button

没有默认行为的按钮，上面显示 value 属性的值，默认为空。

```html
<input type="button" name="button" />
```

#### checkbox

复选框，可设为选中或未选中。

```html
<input type="checkbox" name="checkbox" />
```

#### color

用于指定颜色的控件；在支持的浏览器中，激活时会打开取色器。

```html
<input type="color" name="color" />
```

#### date

输入日期的控件（年、月、日，不包括时间）。在支持的浏览器激活时打开日期选择器或年月日的数字滚轮。

```html
<input type="date" name="date" />
```

#### datetime-local

输入日期和时间的控件，不包括时区。在支持的浏览器激活时打开日期选择器或年月日的数字滚轮。

```html
<input type="datetime-local" name="datetime-local" />
```

#### email

编辑邮箱地址的区域。类似  text 输入，但在支持的浏览器和带有动态键盘的设备上会有确认参数和相应的键盘。

```html
<input type="email" name="email" />
```

#### file

让用户选择文件的控件。使用 accept 属性规定控件能选择的文件类型。

```html
<input type="file" accept="image/*, text/*" name="file" />
```

#### hidden

不显示的控件，其值仍会提交到服务器。举个例子，右边就是一个隐形的控件。

```html
<input type="hidden">
```

#### image

带图像的  submit 按钮。显示的图像由 src 属性规定。如果 src 缺失，alt 属性就会显示。

```html
<input type="image" name="image" src="" alt="image input" />
```

#### month

输入年和月的控件，没有时区。

```html
<input type="month" name="month" />
```

#### number

用于输入数字的控件。如果支持的话，会显示滚动按钮并提供缺省验证（即只能输入数字）。拥有动态键盘的设备上会显示数字键盘。

```html
<input type="number" name="number" />
```

#### password

单行的文本区域，其值会被遮盖。如果站点不安全，会警告用户。

```html
<input type="password" name="password" />
```

#### radio

单选按钮，允许在多个拥有相同 name 值的选项中选中其中一个。

```html
<input type="radio" name="radio" />
```

#### range

此控件用于输入不需要精确的数字。控件是一个范围组件，默认值为正中间的值。同时使用 htmlattrdefmin  和 htmlattrdefmax 来规定值的范围。

```html
<input type="range" name="range" min="0" max="25" />
```

#### reset

此按钮将表单的所有内容重置为默认值。不推荐。

```html
<input type="reset" name="reset" />
```

#### search

用于搜索字符串的单行文字区域。输入文本中的换行会被自动去除。在支持的浏览器中可能有一个删除按钮，用于清除整个区域。拥有动态键盘的设备上的回车图标会变成搜索图标。

```html
<input type="search" name="search" />
```

#### submit

用于提交表单的按钮。

```html
<input type="submit" name="submit" />
```

#### tel

用于输入电话号码的控件。拥有动态键盘的设备上会显示电话数字键盘。

```html
<input type="tel" name="tel" />
```

#### text

默认值。单行的文本区域，输入中的换行会被自动去除。

```html
<input type="text" name="text" />
```

#### time

用于输入时间的控件，不包括时区。

```html
<input type="time" name="time" />
```

#### url

用于输入 URL 的控件。类似 text 输入，但有验证参数，在支持动态键盘的设备上有相应的键盘。

```html
<input type="url" name="url" />
```

#### week

用于输入以年和周数组成的日期，不带时区。

```html
<input type="week" name="week" />
```

#### 测试

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <input type="button" value="按钮">
  <input type="checkbox" name="" id="">
  <input type="color" name="" id="">
  <input type="date" name="" id="">
  <input type="datetime-local" name="" id="">
  <input type="file" name="" id="">
  <input type="email" name="" id="">
  <input type="image" src="" alt="">
  <input type="month" name="" id="">
  <input type="number" name="" id="">
  <input type="password" name="" id="">
  <input type="radio" name="" id="">
  <input type="range" name="" id="">
  <input type="search" name="" id="">
  <input type="search" name="" id="">
  <input type="submit" value="">
  <input type="tel" name="" id="">
  <input type="url" name="" id="">
  <input type="week" name="" id="">
</body>

</html>
```

### <!doctype>

网页的第一个标签通常是`<!doctype>`，表示文档类型，告诉浏览器如何解析网页

**严格模式与混杂模式的区分：**

+ **严格模式**： 又称为标准模式，指浏览器按照`W3C`标准解析代码；
+ **混杂模式**： 又称怪异模式、兼容模式，是指浏览器用自己的方式解析代码。混杂模式通常模拟老式浏览器的行为，以防止老站点无法工作

浏览器渲染页面的两种模式（可通过document.compatMode获取，比如，语雀官网的文档类型是**CSS1Compat**）：

+ **CSS1Compat：标准模式（Strick mode）**，默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。
+ **BackCompat：怪异模式(混杂模式)(Quick mode)**，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。

### \<meta>

`<meta>`标签用于设置或说明网页的元数据，必须放在`<head>`里面。一个`<meta>`标签就是一项元数据，网页可以有多个`<meta>`。`<meta>`标签约定放在`<head>`内容的最前面。

```html
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Page Title</title>
</head>
```

`<meta>`标签有五个属性

+ charset

`<meta>`标签的charset属性，用来指定网页的编码方式。该属性非常重要，如果设置得不正确，浏览器可能无法正确解码，就会显示乱码

+ **name 属性，content 属性**

`<meta>`标签的name属性表示元数据的名字，content属性表示元数据的值。它们合在一起使用，就可以为网页指定一项元数据。

+ **http-equiv 属性，content 属性**

`<meta>`标签的http-equiv属性用来补充 HTTP 回应的头信息字段，如果服务器发回的 HTTP 回应缺少某个字段，就可以用它补充。`<meta>`标签的content属性是对应的字段内容。这两个属性与 HTTP 协议相关，属于高级用法，这里就不详细介绍了。

`meta` 标签由 `name` 和 `content` 属性定义，**用来描述网页文档的属性**，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些`name`作为大家使用的共识，开发者还可以自定义name。

+ `charset`，用来描述HTML文档的编码类型
+ `keywords`，页面关键词
+ `description`，页面描述
+ `refresh`，页面重定向和刷新
+ `viewport`，适配移动端，可以控制视口的大小和比例
  + `content` 参数有以下几种：
    + `width viewport` ：宽度(数值/device-width)
    + `height viewport` ：高度(数值/device-height)
    + `initial-scale` ：初始缩放比例
    + `maximum-scale` ：最大缩放比例
    + `minimum-scale` ：最小缩放比例
    + `user-scalable` ：是否允许用户缩放(yes/no）
+ `robots`搜索引擎索引方式
  + `content` 参数有以下几种：
    + `all`：文件将被检索，且页面上的链接可以被查询；
    + `none`：文件将不被检索，且页面上的链接不可以被查询；
    + `index`：文件将被检索；
    + `follow`：页面上的链接可以被查询；
    + `noindex`：文件将不被检索；
    + `nofollow`：页面上的链接不可以被查询

### 常见的http-equiv

+ Content-Type
+ refresh

### URL特殊字符的转义

+ `!`：%21
+ `#`：%23
+ `$`：%24
+ `&`：%26
+ `'`：%27
+ `(`：%28
+ `)`：%29
+ `*`：%2A
+ `+`：%2B
+ `,`：%2C
+ `/`：%2F
+ `:`：%3A
+ `;`：%3B
+ `=`：%3D
+ `?`：%3F
+ `@`：%40
+ `[`：%5B
+ `]`：%5D

### \<base>

`<base>`标签指定网页内部的所有相对 URL 的计算基准。整张网页只能有一个`<base>`标签，而且只能放在`<head>`里面。它是单独使用的标签，没有闭合标签

### 全局属性

#### tabindex

网页通常使用鼠标操作，但是某些情况下，用户可能希望使用键盘，或者只有键盘可以用。因此，浏览器允许使用 Tab 键，遍历网页元素。也就是说，只要不停按下 Tab 键，网页的焦点就会从一个元素转移到另一个元素，选定焦点元素以后，就可以进行下一步操作，比如按下回车键访问某个链接，或者直接在某个输入框输入文字。

`tabindex`属性，解决这个问题。它的名字的含义，就是 Tab 的顺序（index）。

`tabindex`属性的值是一个整数，表示用户按下 Tab 键的时候，网页焦点转移的顺序。不同的属性值有不同的含义。

+ 负整数：该元素可以获得焦点（比如使用 JavaScript 的`focus()`方法），但不参与 Tab 键对网页元素的遍历。这个值通常是`-1`。
+ `0`：该元素参与 Tab 键的遍历，顺序由浏览器指定，通常是按照其在网页里面出现的位置。
+ 正整数：网页元素按照从小到大的顺序（1、2、3、……），参与 Tab 键的遍历。如果多个元素的`tabindex`属性相同，则按照在网页源码里面出现的顺序遍历。

#### accesskey

`accesskey`属性指定网页元素获得焦点的快捷键，该属性的值必须是单个的可打印字符。只要按下快捷键，该元素就会得到焦点。

激活 accesskey 的操作取决于浏览器及其平台。

|                   | Windows                                                      | Linux                                                        | Mac                   |
| :---------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :-------------------- |
| Firefox           | Alt + Shift + *key*                                          | On Firefox 57 or newer, Control + Option + *key* -OR- Control + Alt + *key* On Firefox 14 or newer, Control + Alt + *key* On Firefox 13 or older, Control + *key* |                       |
| Internet Explorer | Alt + *key*                                                  | N/A                                                          |                       |
| Google Chrome     | Alt + *key*                                                  | Control + Alt + *key*                                        |                       |
| Safari            | Alt + *key*                                                  | N/A                                                          | Control + Alt + *key* |
| Opera 15+         | Alt + *key*                                                  | Control + Alt + *key*                                        |                       |
| Opera 12          | Shift + Esc opens a contents list which are accessible by accesskey, then, can choose an item by pressing *key* |                                                              |                       |

#### hidden

+ 隐藏元素

#### lang，dir

`lang`属性指定网页元素使用的语言。

一些常见的语言代码。

+ zh：中文
+ zh-Hans：简体中文
+ zh-Hant：繁体中文
+ en：英语
+ en-US：美国英语
+ en-GB：英国英语
+ es：西班牙语
+ fr：法语

`dir`属性表示文字的阅读方向，有三个可能的值。

+ `ltr`：从左到右阅读，比如英语。
+ `rtl`：从右到左阅读，阿拉伯语、波斯语、希伯来语都属于这一类。
+ `auto`：浏览器根据内容的解析结果，自行决定。

#### contenteditable

HTML 网页的内容默认是用户不能编辑，`contenteditable`属性允许用户修改内容。它有两个可能的值。

+ `true`或空字符串：内容可以编辑
+ `false`：不可以编辑

#### spellcheck

浏览器一般会自带拼写检查功能，编辑内容时，拼错的单词下面会显示红色的波浪线。`spellcheck`属性就表示，是否打开拼写检查。

#### `data-`属性

`data-`属性用于放置自定义数据。如果没有其他属性或元素合适放置数据，就可以放在`data-`属性。

#### 特殊字符写法

+ `<`：`&lt;`
+ `>`：`&gt;`
+ `"`：`&quot;`
+ `'`：`&apos;`
+ `&`：`&amp;`
+ `©`：`&copy;`
+ `#`：`&num;`
+ `§`：`&sect;`
+ `¥`：`&yen;`
+ `$`：`&dollar;`
+ `£`：`&pound;`
+ `¢`：`&cent;`
+ `%`：`&percnt;`
+ `*`：`$ast;`
+ `@`：`&commat;`
+ `^`：`&Hat;`
+ `±`：`&plusmn;`
+ 空格：`&nbsp;`

### 列表

+ ol（有序列表）
  + **reversed**
  + **start**
  + **type**
+ ul (无序列表)
+ dl （自定义列表）
  + `<dl>`标签是一个块级元素，表示一组术语的列表（description list）。术语名（description term）由`<dt>`标签定义，术语解释（description detail）由`<dd>`标签定义。`<dl>`常用来定义词汇表。

### img陌生属性

+ **srcset，sizes**

  + `srcset`属性用来指定多张图像，适应不同像素密度的屏幕。它的值是一个逗号分隔的字符串，每个部分都是一张图像的 URL，后面接一个空格，然后是像素密度的描述符
  + 像素密度的适配，只适合显示区域一样大小的图像。如果希望不同尺寸的屏幕，显示不同大小的图像，`srcset`属性就不够用了，必须搭配`sizes`属性
  + `sizes`属性的值是一个逗号分隔的字符串，除了最后一部分，前面每个部分都是一个放在括号里面的媒体查询表达式，后面是一个空格，再加上图像的显示宽度。

+ **referrerpolicy**

  `<img>`导致的图片加载的 HTTP 请求，默认会带有Referer的头信息。referrerpolicy属性对这个行为进行设置。

+ **crossorigin**

  有时，图片和网页属于不同的网站，网页加载图片就会导致跨域请求，对方服务器可能要求跨域认证。`crossorigin`属性用来告诉浏览器，是否采用跨域的形式下载图片，默认是不采用。

  简单说，只要打开了这个属性，HTTP 请求的头信息里面，就会加入`origin`字段，给出请求发出的域名，不打开这个属性就不加。

  一旦打开该属性，它可以设为两个值。

  + `anonymous`：跨域请求不带有用户凭证（通常是 Cookie）。
  + `use-credentials`：跨域请求带有用户凭证。

+ **loading**

  + `auto`：浏览器默认行为，等同于不使用`loading`属性。
  + `lazy`：启用懒加载。
  + `eager`：立即加载资源，无论它在页面上的哪个位置。

### picture

`<picture>`是一个容器标签，内部使用`<source>`和`<img>`，指定不同情况下加载的图像

```html
<picture>
  <source media="(max-width: 500px)" srcset="cat-vertical.jpg">
  <source media="(min-width: 501px)" srcset="cat-horizontal.jpg">
  <img src="cat.jpg" alt="cat">
</picture>
```

```html
<picture>
  <source type="image/svg+xml" srcset="logo.xml">
  <source type="image/webp" srcset="logo.webp"> 
  <img src="logo.png" alt="ACME Corp">
</picture>
```

浏览器按照`<source>`标签出现的顺序，依次检查是否支持`type`属性指定的图像格式，如果支持就加载图像，并且不再检查后面的`<source>`标签了。上面例子中，图像加载优先顺序依次为 svg 格式、webp 格式和 png 格式。

### \<figure>,\<figcaption>

`<figure>`标签可以理解为一个图像区块，将图像和相关信息封装在一起。`<figcaption>`是它的可选子元素，表示图像的文本描述，通常用于放置标题，可以出现多个

### 链接其余属性

+ **hreflang**

  `hreflang`属性给出链接指向的网址所使用的语言，纯粹是提示性的，没有实际功能。

+ **target**

  + `_self`：当前窗口打开，这是默认值。
  + `_blank`：新窗口打开。
  + `_parent`：上层窗口打开，这通常用于从父窗口打开的子窗口，或者`<iframe>`里面的链接。如果当前窗口没有上层窗口，这个值等同于`_self`。
  + `_top`：顶层窗口打开。如果当前窗口就是顶层窗口，这个值等同于`_self`

+ **rel**

  + `rel`属性说明链接与当前页面的关系。
  + 常见的`rel`属性的值。
    + `alternate`：当前文档的另一种形式，比如翻译。
    + `author`：作者链接。
    + `bookmark`：用作书签的永久地址。
    + `external`：当前文档的外部参考文档。
    + `help`：帮助链接。
    + `license`：许可证链接。
    + `next`：系列文档的下一篇。
    + `nofollow`：告诉搜索引擎忽略该链接，主要用于用户提交的内容，防止有人企图通过添加链接，提高该链接的搜索排名。
    + `noreferrer`：告诉浏览器打开链接时，不要将当前网址作为 HTTP 头信息的`Referer`字段发送出去，这样可以隐藏点击的来源。
    + `noopener`：告诉浏览器打开链接时，不让链接窗口通过 JavaScript 的`window.opener`属性引用原始窗口，这样就提高了安全性。
    + `prev`：系列文档的上一篇。
    + `search`：文档的搜索链接。
    + `tag`：文档的标签链接。

+ **referrerpolicy**

  + `referrerpolicy`属性用于精确设定点击链接时，浏览器发送 HTTP 头信息的`Referer`字段的行为。

  + 该属性可以取下面八个值：`no-referrer`、`no-referrer-when-downgrade`、`origin`、`origin-when-cross-origin`、`unsafe-url`、`same-origin`、`strict-origin`、`strict-origin-when-cross-origin`。

  + 其中，`no-referrer`表示不发送`Referer`字段，`same-origin`表示同源时才发送`Referer`字段，`origin`表示只发送源信息（协议+域名+端口）

+ **ping**

  + `ping`属性指定一个网址，用户点击的时候，会向该网址发出一个 POST 请求，通常用于跟踪用户的行为。

+ **type**

  + `type`属性给出链接 URL 的 MIME 类型，比如到底是网页，还是图像或文件。它也是纯粹提示性的属性，没有实际功能。

+ **download**

  + `download`属性表明当前链接用于下载，而不是跳转到另一个 URL。

#### 邮箱链接

链接也可以指向一个邮件地址，使用`mailto`协议。用户点击后，浏览器会打开本机默认的邮件程序，让用户向指定的地址发送邮件。

除了邮箱，邮件协议还允许指定其他几个邮件要素。

+ `subject`：主题
+ `cc`：抄送
+ `bcc`：密送
+ `body`：邮件内容

使用方法是将这些邮件要素，以查询字符串的方式，附加在邮箱地址后面。

这些要素的值需要经过 URL 转义，比如空格转成`%20`。

也可以不指定邮箱

#### 电话链接

如果是手机浏览的页面，还可以使用`tel`协议，创建电话链接。用户点击该链接，会唤起电话，可以进行拨号。

### 资源预加载

+ \<link rel="preload">告诉浏览器尽快下载并缓存资源（如脚本或样式表），该指令优先级较高，浏览器肯定会执行；还有两个优点：一是允许指定预加载资源的类型，二是允许`onload`事件的回调函数。下面是`rel="preload"`配合`as`属性，告诉浏览器预处理资源的类型，以便正确处理。

+ `as`属性指定加载资源的类型，它的值一般有下面几种。

  + "script"
  + "style"
  + "image"
  + "media"
  + "document"

+ \<link rel="prefetch">如果后续的页面需要某个资源，并且希望预加载该资源，以便加速页面渲染。该指令不是强制性的，优先级较低，浏览器不一定会执行。这意味着，浏览器可以不下载该资源，比如连接速度很慢时。

+ \<link rel="preconnect">

  `<link rel="preconnect">`要求浏览器提前与某个域名建立 TCP 连接。当你知道，很快就会请求该域名时，这会很有帮助。

+ \<link rel="dns-prefetch">

  `<link rel="dns-prefetch">`要求浏览器提前执行某个域名的 DNS 解析。

-

+ \<link rel="prerender">

  `<link rel="prerender">`要求浏览器加载某个网页，并且提前渲染它。用户点击指向该网页的链接时，就会立即呈现该页面。如果确定用户下一步会访问该页面，这会很有帮助

### 其他元素

`<wbr>`：用于宽度不够时换行

`<blockquote>`，`<cite>`，`<q>`

+ `<blockquote>`是一个块级标签，表示引用他人的话。浏览器会在样式上，与正常文本区别显示。
+ `<cite>`标签表示引言出处或者作者，浏览器默认使用斜体显示这部分内容。
+ `<q>`是一个行内标签，也表示引用。它与`<blockquote>`的区别，就是它不会产生换行。

如果要表示多行代码，`<code>`标签必须放在`<pre>`内部。`<code>`本身仅表示一行代码。

`<sub>`标签将内容变为下标，`<sup>`标签将内容变为上标。它们都是行内元素，主要用于数学公式、分子式等。

`<u>`标签是一个行内元素，表示对内容提供某种注释，提醒用户这里可能有问题，基本上只用来表示拼写错误。浏览器默认以下划线渲染内容。

`<s>`标签是一个行内元素，为内容加上删除线。

`<kbd>`标签是一个行内元素，原意是用户从键盘输入的内容，现在扩展到各种输入，包括语音输入。浏览器默认以等宽字体显示标签内容。

`<samp>`标签是一个行内元素，表示计算机程序输出内容的一个例子。浏览器默认以等宽字体显示。

`<mark>`是一个行内标签，表示突出显示的内容。Chrome 浏览器默认会以亮黄色背景，显示该标签的内容。

`<time>`是一个行内标签，为跟时间相关的内容提供机器可读的格式。

```html
<p>运动会预定<time datetime="2015-06-10">下周三</time>举行。</p>
```

`<time>`的`datetime`属性，用来指定机器可读的日期，可以有多种格式。

+ 有效年份：`2011`
+ 有效月份：`2011-11`
+ 有效日期：`2011-11-18`
+ 无年份的日期：`11-18`
+ 年度的第几周：`2011-W47`
+ 有效时间：`14:54`、`14:54:39`、`14:54:39.929`
+ 日期和时间：`2011-11-18T14:54:39.929`

`<data>`标签与`<time>`类似，也是提供机器可读的内容，但是用于非时间的场合。

```
<p>本次马拉松比赛第一名是<data value="39">张三</data></p>。
```

上面代码中，选手的机读数据就放在`<data>`标签的`value`属性。

`<address>`标签是一个块级元素，表示某人或某个组织的联系方式。

该标签有几个注意点。

（1）如果是文章里提到的地址（比如提到搬家前的地址），而不是联系信息，不要使用`<address>`标签。

（2）`<address>`的内容不得有非联系信息，比如发布日期。

（3）`<address>`不能嵌套，并且内部不能有标题标签（`<h1>`~`<h6>`），也不能有`<article>`、`<aside>`、`<section>`、`<nav>`、`<header>`、`<footer>`等标签。

（4）通常，`<address>`会放在`<footer>`里面

`<abbr>`标签是一个行内元素，表示标签内容是一个缩写。它的`title`属性给出缩写的完整形式，或者缩写的描述。鼠标悬停在该元素上方时，`title`属性值作为提示，会完整显示出来。

`<track>`标签用于指定视频的字幕，格式是 WebVTT （`.vtt`文件），放置在`<video>`标签内部。它是一个单独使用的标签，没有结束标签。

`<dialog>`标签表示一个可以关闭的对话框。默认情况下，对话框是隐藏的，不会在网页上显示。如果要让对话框显示，必须加上`open`属性。`<dialog>`元素的 JavaScript API 提供`Dialog.showModal()`和`Dialog.close()`两个方法，用于打开/关闭对话框。

\<details>标签用来折叠内容，浏览器会折叠显示该标签的内容。\<details>标签的open属性，用于默认打开折叠。`<summary>`标签用来定制折叠内容的标题。

通过 CSS 设置`summary::-webkit-details-marker`，可以改变标题前面的三角箭头。`Details`元素的`open`属性返回`<details>`当前是打开还是关闭。`Details`元素有一个`toggle`事件，打开或关闭折叠时，都会触发这个事件。

### 文档碎片

1： 浅谈关于文档碎片的理解

 js 操作DOM 时发生了什么？

 每一次对DOM 操作都发生了 "重排", 这严重消耗性能。 一般通常的做法是减少dom 操作， 减少发生重排的做法。

2： 什么是文档碎片？

文档碎片是一种虚拟的DOM节点

 document.createDocumentFragment()

一个容器用于暂时存放创建DOM 元素。

3： 文档碎片有什么作用？

 将需要添加的大量元素，先添加到文档文档碎片中，再将文档碎片添加到需要插入的位置， 大大大减少DOM 操作， 提高性能。

### JS引入时defer和async的区别

defer在文档解析完成后执行，按照引入顺序执行

async在加载完后就执行，不一定按引入顺序执行

### 遍历节点树

+ parentNode
+ childNode
+ firstChild
+ lastChild
+ nextSibling
+ previousSibling
+ parentElement
+ children
+ node.childElemnetCount
+ firstElementChild
+ lastElementChild
+ nextElementSibling/previousElementSibling

#### 节点四个属性

+ nodeName
+ nodeValue
+ nodeType
+ attributes

### 获取窗口属性

+ window.pageXOffset/pageYOffset
+ document.body/documentElement.scrollLeft/scrollTop(IE8及以下)

获取视口尺寸

+ window.innerWidth/innerHeight
+ document.documentElement.clientWidth/clientHeight
  + 标准模式下
+ document.body.clientWidth/clientHeight
  + 怪异模式下

alert(window.top.document.compatMode) ;
//BackCompat 表示怪异模式
//CSS1Compat 表示标准模式

查看元素的几何尺寸

+ domEle.getBoundingClientRect()

查看元素的尺寸

dom.offsetWidth,dom.offsetHeight（视觉上的大小，包含padding）

查看元素位置

dom.offsetLeft,dom.offsetTop

对于无定位父级元素，返回相对文档的坐标，对于有定位父级元素，返回相对于最近有定位的父级的坐标

dom.offsetParent(body.offsetParent返回null)

**scrollBy()会累加之前滚动的距离**

查询计算样式(计算样式只读)

window.getComputedStyle(ele,pseudoElt)

pseudoElt 可选

指定一个要匹配的伪元素的字符串。必须对普通元素省略（或`null`）。

div.currentStyle-->CSSStyleDeclaration;(IE独有)

### requestAnimationFrame

requestAnimationFrame 比起 setTimeout、setInterval的优势主要有两点：

1、requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。

2、在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。

cancelAnimationFrame()接收一个参数 requestAnimationFrame默认返回一个id，cancelAnimationFrame只需要传入这个id就可以停止了。

### HTML5 drag API

+ dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。
+ darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。
+ dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。
+ dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。
+ dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。
+ drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。
+ dragend：事件主体是被拖放元素，在整个拖放操作结束时触发

### 真实DOM的主要属性

+ nodeName节点名字(一般为大写，当节点为纯文本时是#text)
+ nodeType 节点类型
  + 文档节点（document）：9
  + 元素节点（element）：1
  + 属性节点（attr）：2
  + 文本节点（text）：3
  + 文档片断节点（DocumentFragment）：11
  + 文档类型节点（DocumentType）：10
  + 注释节点（Comment）：8

+ childNodes 所有子节点包含文本节点
+ children 文档节点，不包含纯文字
+ parentNode 父元素
+ previousSibling 上一个节点（含文字）

#### nodeValue 获取节点的值

+ 元素节点的 nodeValue 是 undefined 或 null
+ 文本节点的 nodeValue 是文本本身
+ 属性节点的 nodeValue 是属性值
+ 文档节点的 nodeName 始终是null

**获取属性节点为element.attributes[0]**

**纯文本节点会有data或textContent属性获取文字**

#### 节点层次关系属性

根据当前节点按层级查找的一些属性

+ childNodes：获取当前节点的所有子节点
+ firstChild：获取当前节点的第一个子节点
+ lastChild：获取当前节点的最后一个子节点
+ ownerDocument获取该节点的文档的根节点，相当于document
+ parentNode：获取当前节点的父节点
+ previousSibling：获取当前节点的前一个同级节点
+ nextSibling：获取当前节点的下一个节点
+ previousSibling：获取当前节点的上一个节点
+ attributes：获取当前节点的所有属性
+ className：用于获取/设置当前标签的class属性值
+ innerHTML：用于获取/设置起始标签和结束标签中的内容
+ innerText：用于获取/设置起始标签和结束标签中的文本

[官方文档](https://developer.mozilla.org/zh-CN/docs/Web/API/Element)

### 关闭iOS中的首字母大写

`autocapitalize="off"`

当设置了autocapitalize="words"时，每个单词的开头字母会自动大写。

当设置了autocapitalize="characters" 时，每个字母都会大写。

当设置了autocapitalize="sentences" 时，每句开头字母会自动大写。

`autocorrect="off"`自动更正

### src和href

src 用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。  

### 自适应和响应式区别

区别：
　　**自适应：需要开发多套界面；**
　　**响应式：只需开发一套界面。**
**1.自适应：**
　　通过检测视口分辨率，来判断当前访问的设备是：pc端、平板、手机，从而请求服务层，返回不同的页面；响应式设计通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容。
**2.响应式：**
　　对页面做的屏幕适配是在一定范围：比如pc端（>1024）一套适配,平板（768-1024）一套适配，手机端（<768）一套适配;响应式一套页面全部适配。（可以想象：响应式设计要考虑的内容要比自适应设计复杂的多）

#### 响应式优缺点和标志

##### 标志

+ 面包屑菜单
+ 改变浏览器宽度会在不同分辨率下显示不同的布局

##### 优点

+ 面对不同分辨率设备灵活性强
+ 能够快捷解决多设备显示适应问题

##### 缺点

+ 仅适用布局、信息、框架并不复杂的部门类型网站
+ 兼容各种设备工作量大，效率低下
+ 代码累赘，会出现隐藏无用的元素，加载时间加长
+ 其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果
+ 一定程度上改变了网站原有的布局结构，会出现用户混淆的情况

#### 自适应网站优缺点和标志

##### 标志

+ 大多只是适配单个终端的主流N个主流视口（2-3个）
+ 当视口大小低于设置的最小视口时，界面会出现显示不全，溢出，并出现横向滑动指示器（主要出现在pc端，移动端决不允许出现这种情况）
+ 总体框架不变，横线布局的板块大多会有所减少

##### 优点

+ 对网站的复杂程度兼容性更大
+ 实施起来代价更低，
+ 代码更高效
+ 测试更容易，运营相对更精准（图片可控性更高）

##### 缺点

+ 在移动端设计大行其道之下，同一个网站，往往需要为不同的设备开发不同的页面，增加开发成本
+ 当需求改变时，可能会改动多套代码。流程繁琐。

## Vue

### Vue实例挂载的过程发生了什么

挂载过程通常指app.mount()过程

1.初始化

创建组件实例，初始化组件状态，创建各种响应式数据

2.建立更新机制

建立更新机制这一步会立即执行一次组件更新函数，这会首次执行组件渲染函数并执行patch将前面获得vnode转换为dom;同时首次执行渲染函数会创建它内部响应式数据和组件更新函数之间的依赖关系，这使得以后数据变化时会执行对应的更新函数。

### Vue2实现双向绑定

```html
<body>

    <input type="text" id="username"><br>
    显示值<p id="user"></p>
    <script>
        let obj = {

        };
        Object.defineProperty(obj, "username", {
            get: function () {
                console.log("取值")
            },
            set: function (val) {
                // console.log(val)
                document.querySelector("#user").innerText = val

            }
        })

        document.querySelector("#username").addEventListener("keyup", function () {
            obj.username = event.target.value
        })

    </script>
</body>

```

### 实现对象变化监听

```js
//  观察类
export class Observer {
  constructor(value) {
    this.value = value
    if (Array.isArray(value)) {

    } else {
      this.walk(value)
    }
  }

  walk(obj) {
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) {

      defineReactive(obj, keys[i])
    }
  }
}


function defineReactive(obj, key, val) {
  //减少一个变量
  if (arguments.length === 2) {
    val = obj[key]
  }
  if (typeof val === 'object') {
    new Observer(val)
  }
  Object.defineProperty(obj, key, {
    get() {
      console.log(`${key}属性被读取`)
      return val;
    },
    set(newVal) {
      val = newVal;
      console.log(`${key}属性被设置为${newVal}`)
    }
  })
}
```

### 实现响应式

+ 发布订阅模式
+ 双向数据绑定
+ 基本的响应式

```html
<body>

  数据1<span class="box-1"></span>
  数据2<span class="box-2"></span>

  <script>

    let Dep = {
      clientList: {},
      // 添加订阅
      listen: function (key, fn) {
        if (!this.clientList[key]) {
          this.clientList[key] = []
        }
        this.clientList[key].push(fn)
      },
      // 触发
      trigger: function () {
        let key = Array.prototype.shift.call(arguments),
          fns = this.clientList[key];
        if (!fns || fns.length === 0) {
          return;
        }

        for (let i = 0, fn; i < fns.length; i++) {
          fn = fns[i]
          fn.apply(this, arguments)
        }
      }
    }


    let dataHijack = function ({ data, tag, datakey, selector }) {
      let value = "",
        el = document.querySelector(selector);

      Object.defineProperty(data, datakey, {
        get: function () {
          console.log("get")
          return value
        },
        set: function (val) {
          // console.log(val)
          // document.querySelector("#user").innerText = val
          console.log('set');
          value = val
          Dep.trigger(tag, val)
        }
      })
      Dep.listen(tag, function (text) {
        el.innerHTML = text
      })
    }
  </script>


  <script>
    let dataObj = {}
    dataHijack({
      data: dataObj,
      tag: "view-1",
      datakey: "one",
      selector: ".box-1"
    })

    dataHijack({
      data: dataObj,
      tag: "view-2",
      datakey: "two",
      selector: ".box-2"
    })

    dataObj.one = "迪迦"
    dataObj.two = "泰罗"

  </script>
</body>
```

### Vue3实现对象双向绑定

```js
const user = [1, 2, 3, 4]

let propyUser = new Proxy(user, {
  get(target, prop) {
    console.log("拦截get")
    return Reflect.get(target, prop)
  },

  set(target, prop, value) {
    console.log("拦截set")
    return Reflect.set(target, prop, value)
  },
  deleteProperty(target, prop) {
    console.log("拦截del")
    return Reflect.deleteProperty(target, prop)
  }
})
```

### Diff

Diff算法通过比较新旧VDOM以最小的代价更新真实DOM。由于频繁操作DOM开销大，所以通过JS对象模拟DOM结构生成VDOM，在VDOM上操作过后一次性更新至真实DOM。Diff算法的比较原则如下： 1.不做跨层次比较，只在同层次比较节点。 2.如果tag和key不相同，则认为是不同节点，不进行比较而是直接替换。如果tag和key相同，则进行深入比较。 3.深入比较先比较节点属性，再对节点的孩子进行逐个比较。 Diff算法的核心是patch函数，patch函数首先调用sameNode函数比较节点是否相同： 1.sameVnode:通过比较两个VDOM的tag和key判断它们是否相同。相同节点调用patchVnode函数进行深入比较 2.patchNode:先比较并更新节点的属性，再比较它们的孩子节点，分为以下几种情况：(1)旧DOM无孩子，新DOM有孩子，直接进行插入操作。(2)旧DOM有孩子，新DOM无孩子，直接进行删除操作。（3）旧DOM有孩子，新DOM有孩子，调用updateChildren函数对孩子节点进行比较。 3.updateChildren：比较新旧节点的孩子列表，这里有很多种实现方式，介绍一种常用的：四个指针指向新旧孩子列表的首尾，通过首尾之间两两比较找到相同节点。如果有相同节点则移动旧节点位置，对节点进行复用并移动对应指针；如果没有相同节点，采用遍历的方式查找旧孩子列表中与当前新孩子首节点相同节点，如果找到了则可以复用，没有找到则只能进行插入操作。 Diff算法的核心思想是能复用尽量复用，尽可能减少操作DOM的开销。

### nextTick

在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。

1. Vue 在更新 DOM 时是**异步**执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用。
2. 所以当我们想在修改数据后立即看到dom执行结果就需要用到nextTick方法。
3. 它会在callbacks里面加入我们传入的函数，然后用timerFunc异步方式调用它们，首选的异步方式会是Promise。这让我明白了为什么可以在nextTick中看到dom操作结果。

### 样式穿透

在Vue2中 我们经常使用 **>>>** 或 **/deep/** 样式穿透 修改elementui里面的样式

但是Vue3中 弃用了 **>>>** 和 **/deep/** 使用 **:deep()** 代替

### watch和computed的区别

1. 计算属性可以**从组件数据派生出新数据**，最常见的使用方式是设置一个函数，返回计算之后的结果，computed和methods的差异是它具备缓存性，如果依赖项不变时不会重新计算。侦听器**可以侦测某个响应式数据的变化并执行副作用**（可能会影响到其他函数或变量，那么这种影响就是一种副作用），常见用法是传递一个函数，执行副作用，watch没有返回值，但可以执行异步操作等复杂逻辑。
2. 计算属性常用场景是简化行内模板中的复杂表达式，模板中出现太多逻辑会是模板变得臃肿不易维护。侦听器常用场景是状态变化之后做一些额外的DOM操作或者异步操作。选择采用何用方案时首先看是否需要派生出新值，基本能用计算属性实现的方式首选计算属性。
3. 使用过程中有一些细节，比如计算属性也是可以传递对象，成为既可读又可写的计算属性。watch可以传递对象，设置deep、immediate等选项。
4. vue3中watch选项发生了一些变化，例如不再能侦测一个点操作符之外的字符串形式的表达式； reactivity API中新出现了watch、watchEffect可以完全替代目前的watch选项，且功能更加强大。

### vue组件传值的方法

1、父组件向子组件进行传值

+ 在子组件绑定父的数据，子组件通过props接受参数。
+ ref
+ $attrs
+ $children（vue3废除）

2、子组件向父组件进行传值

+ 父组件中的标签上定义自定义事件，在事件内部获取参数
+ $emit('父组件中的自定义事件',参数)
+ $on(vue3废除)
+ $listeners（vue3废除）

3、vue3祖孙组件之间

+ 使用provide，inject
+ eventbus
+ vuex
+ pinia

4、兄弟组件

+ $parent
+ 通过eventbus
+ $root
+ vuex
+ pinia

### $listeners

通过$attrs将为在props中声明的属性传递给子组件，attrs本身是非响应式的除非访问的是响应式对象

vue2中使用listeners获取事件，vue3中移除，均合并在attrs中

vm.$listeners

> 2.4.0 新增

+ **类型**：`{ [key: string]: Function | Array<Function> }`

+ **只读**

+ **详细**：

  包含了父作用域中的 (不含 `.native` 修饰器的) `v-on` 事件监听器。它可以通过 `v-on="$listeners"` 传入内部组件——在创建更高层次的组件时非常有用。

### v-once

会将首次计算结果存入缓存对象，组件再次渲染时会从缓存中获取，避免再次计算

### 手写组合API

#### reactive和shallowReactive

```js
const handler = {
  get(target, prop) {
    console.log("拦截get")
    if(prop==="_is_reactive") return true;
    return Reflect.get(target, prop)
  },

  set(target, prop, value) {
    console.log("拦截set")
    return Reflect.set(target, prop, value)
  },
  deleteProperty(target, prop) {
    console.log("拦截del")
    return Reflect.deleteProperty(target, prop)
  }
}


function reactive(target) {
  if (target && typeof target === "object") {
    Object.entries(target).forEach(([key, value]) => {
      if (typeof value === "object") {
        target[key] = reactive(value)
      }
    })
    return new Proxy(target, handler)
  }
}


function shallowReactive(target) {
  if (target && typeof target === "object") {
    return new Proxy(target, handler)
  }
}

const state = reactive({
  a: 1,
  b: 2,
  c: {
    d: 3
  }
})

const state1 = shallowReactive({
  a: 3,
  b: {
    c: 4
  }
})
```

#### ref和shallowRef

```js
function ref(target) {

  if (target && typeof target === "object") {
    target = reactive(target)
  }

  return {
    _is_ref:true,
    _value: target,
    get value() {
      console.log('ref-get')
      return this._value
    },
    set value(newValue) {
      console.log("ref-set")
      this._value = newValue
    }
  }
}

const str = ref("abc")
str.value = "hello"

const obj = ref({
  a: 1,
  b: {
    c: 2
  }
})

function shallowRef(target) {
  return {
    _value: target,
    _is_ref:true,
    get value() {
      console.log('ref-get')
      return this._value
    },
    set value(newValue) {
      console.log("ref-set")
      this._value = newValue
    }
  }
}

const data = shallowRef({
  a: 1,
  b: {
    c: 2
  }
})
```

### 单页应用与多页应用的区别

|                 | 单页面应用（SPA）         | 多页面应用（MPA）                   |
| :-------------- | :------------------------ | :---------------------------------- |
| 组成            | 一个主页面和多个页面片段  | 多个主页面                          |
| 刷新方式        | 局部刷新                  | 整页刷新                            |
| url模式         | 哈希模式                  | 历史模式                            |
| SEO搜索引擎优化 | 难实现，可使用SSR方式改善 | 容易实现                            |
| 数据传递        | 容易                      | 通过url、cookie、localStorage等传递 |
| 页面切换        | 速度快，用户体验良好      | 切换加载资源，速度慢，用户体验差    |
| 维护成本        | 相对容易                  | 相对复杂                            |

#### 单页应用优缺点

优点：

+ 具有桌面应用的即时性、网站的可移植性和可访问性
+ 用户体验好、快，内容的改变不需要重新加载整个页面
+ 良好的前后端分离，分工更明确

缺点：

+ 不利于搜索引擎的抓取
+ 首次渲染速度相对较慢

### v-model简写

v-model=v-on +v-bind

### 父子组件生命周期

挂载阶段

执行顺序为：

父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted

更新阶段

执行顺序为：

父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updated

销毁阶段

执行顺序为：

父beforeDestroy -> 子beforeDestroy -> 子destroyed -> 父destroyed

规律就是：父组件先开始执行，然后等到子组件执行完，父组件收尾。

原因：vue创建是一个递归过程，先创建父子组件，有子组件就会创建子组件子组件创建会添加mounted钩子，等patch结束再执行

### new Vue背后的事情

+ initLifecycle(vm)

+ initEvents(vm)

+ initRender(vm)

+ callHook(vm, 'beforeCreate')

+ initInjections(vm) // resolve injections before data/props

+ initState(vm)

+ initProvide(vm) // resolve provide after data/props

+ callHook(vm, 'created')

### 生成响应式数据

$set 添加响应式数据

### v-show和v-if的区别和原理

**共同点**

`v-show` 与 `v-if` 的作用效果是相同的(不含v-else)，都能控制元素在页面是否显示

**区别**

控制手段：`v-show`隐藏则是为该元素添加`css--display:none`，`dom`元素依旧还在。`v-if`显示隐藏是将`dom`元素整个添加或删除

性能消耗：`v-if`有更高的切换消耗；`v-show`有更高的初始渲染消耗；

**使用场景**

`v-if` 与 `v-show` 都能控制`dom`元素在页面的显示

`v-if` 相比 `v-show` 开销更大的（直接操作`dom`节点增加与删除）

如果需要非常频繁地切换，则使用 v-show 较好

如果在运行时条件很少改变，则使用 v-if 较好

### Vue2中v-if与v-for不建议一起用

**在vue2中v-for优先级高于v-if**

**在vue3中v-if 与 v-for 一起使用处于同一节点时， v-if 比 v-for 优先级更高，这意味着 v-if 没有权限访问 v-for 中的变量。**

**注意事项**

1. 永远不要把 `v-if` 和 `v-for` 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）
2. 如果避免出现这种情况，则在外层嵌套`template`（页面渲染不生成`dom`节点），在这一层进行v-if判断，然后在内部进行v-for循环

### Vue生命周期

**beforeCreate -> created**

+ 初始化`vue`实例，进行数据观测

**created**

+ 完成数据观测，属性与方法的运算，`watch`、`event`事件回调的配置
+ 可调用`methods`中的方法，访问和修改data数据触发响应式渲染`dom`，可通过`computed`和`watch`完成数据计算
+ 此时`vm.$el` 并没有被创建

**created -> beforeMount**

+ 判断是否存在`el`选项，若不存在则停止编译，直到调用`vm.$mount(el)`才会继续编译
+ 优先级：`render` > `template` > `outerHTML`
+ `vm.el`获取到的是挂载`DOM`的

**beforeMount**

+ 在此阶段可获取到`vm.el`
+ 此阶段`vm.el`虽已完成DOM初始化，但并未挂载在`el`选项上

**beforeMount -> mounted**

+ 此阶段`vm.el`完成挂载，`vm.$el`生成的`DOM`替换了`el`选项所对应的`DOM`

**mounted**

+ `vm.el`已完成`DOM`的挂载与渲染，此刻打印`vm.$el`，发现之前的挂载点及内容已被替换成新的DOM

**beforeUpdate**

+ 更新的数据必须是被渲染在模板上的（`el`、`template`、`render`之一）
+ 此时`view`层还未更新
+ 若在`beforeUpdate`中再次修改数据，不会再次触发更新方法

**updated**

+ 完成`view`层的更新
+ 若在`updated`中再次修改数据，会再次触发更新方法（`beforeUpdate`、`updated`）

**beforeDestroy**

+ 实例被销毁前调用，此时实例属性与方法仍可访问

**destroyed**

+ 完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器
+ 并不能清除DOM，仅仅销毁实例

Vue生命周期总共可以分为8个阶段：**创建前后, 载入前后, 更新前后, 销毁前后**，以及一些特殊场景的生命周期。vue3中新增了三个用于调试和服务端渲染场景。

| 生命周期v2    | 生命周期v3          | 描述                                     |
| ------------- | ------------------- | ---------------------------------------- |
| beforeCreate  | beforeCreate        | 组件实例被创建之初                       |
| created       | created             | 组件实例已经完全创建                     |
| beforeMount   | beforeMount         | 组件挂载之前                             |
| mounted       | mounted             | 组件挂载到实例上去之后                   |
| beforeUpdate  | beforeUpdate        | 组件数据发生变化，更新之前               |
| updated       | updated             | 数据数据更新之后                         |
| beforeDestroy | **beforeUnmounted** | 组件实例销毁之前                         |
| destroyed     | **unmounted**       | 组件实例销毁之后                         |
| activated     | activated           | keep-alive 缓存的组件激活时              |
| deactivated   | deactivated         | keep-alive 缓存的组件停用时调用          |
| errorCaptured | errorCaptured       | 捕获一个来自子孙组件的错误时被调用       |
| -             | **renderTracked**   | 调试钩子，响应式依赖被收集时调用         |
| -             | **renderTriggered** | 调试钩子，响应式依赖被触发时调用         |
| -             | **serverPrefetch**  | ssr only，组件实例在服务器上被渲染前调用 |

### 数据请求在created和mouted的区别

+ `created`是在组件实例一旦创建完成的时候立刻调用，这时候页面`dom`节点并未生成；

+ `mounted`是在页面`dom`节点渲染完毕之后就立刻执行的。触发时机上`created`是比`mounted`要更早的
+ 两者的相同点：都能拿到实例对象的属性和方法
+ 放在`mounted`中的请求有可能导致页面闪动（因为此时页面`dom`结构已经生成），但如果在页面加载前完成请求，则不会出现此情况。
+ 建议对页面内容的改动放在`created`生命周期当中。

### 首页加载问题

在页面渲染的过程，导致加载速度慢的因素可能如下：

+ 网络延时问题
+ 资源文件体积是否过大
+ 资源是否重复发送请求去加载了
+ 加载脚本的时候，渲染内容堵塞了

常见的几种SPA首屏优化方式

+ 减小入口文件积
+ 静态资源本地缓存
+ UI框架按需加载
+ 图片资源的压缩
+ 组件重复打包
+ 开启GZip压缩
+ 使用SSR

### Vue编译器作用

1. Vue中有个独特的编译器模块，称为“compiler"，它的主要作用是将用户编写的template编译为js中可执行的
   render函数。
2. 之所以需要这个编译过程是为了便于前端程序员能高效的编写视图模板。相比而言，我们还是更愿意用HTML来编写视图，直观且高效。手写render函数不仅效率底下，而且失去了编译期的优化能力。
3. 在Vue中编译器会先对template进行解析，这一步称为parse，结束之后会得到一个JS对象，我们成为抽象语法树AST，然后是对AST进行深加工的转换过程，这一步成为transform，最后将前面得到的AST生成为JS代码，也就是render函数。

### render()与template异同点

#### 共同点

都是类编译器

render函数是template的下一步

**vue渲染过程**

 template=>render() h=>原生JS的createElement()=>创建真实元素=>生成虚拟dom=>真实dom

**在一值多判断的情况使用render抽离判断**

#### 不同

+ 高复用性
+ 使模板更加简洁明了
+ 集中化处理

#### 自动注册全局组件

```js
import Vue from "vue";
// 大写字符串首字母 返回当前字符串
function changeStr(str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
}

// require.context=>webpack API(动态引入文件)
// 1. 当前路径
// 2. 是否匹配子级
// 3. 查找的文件格式
const requireComponent = require.context('./', false, /\.vue$/)
// console.log(requireComponent.keys())
requireComponent.keys().forEach(fileName => {
  const config = requireComponent(fileName);
  const componentName = changeStr(fileName.replace(/^\.\//, '').replace(/\.\w+$/, ''))
  // 注册组件
  //console.log(config.default)
  Vue.component(componentName, config.default || config)
});
```

```js
import global from './components/common/global.js'
```

#### 优化鉴权

```js
Vue.directive("display-key", {
  inserted(el, binding) {
    let displaykey = binding.value

    if (displaykey) {
      let hasKey = checkArray(displaykey)
      if (!hasKey) {
        el.parentNode && el.parentNode.removeChild(el)
      }
    } else {
      throw new Error("需要一个key值")
    }
  }
})
```

通过全局指令去进行集中处理，将元素是否渲染进行统一处理

### data是一个函数不是一个对象

`vue`实例的时候定义`data`属性既可以是一个对象，也可以是一个函数

组件中定义`data`属性，只能是一个函数

目的是为了防止多个组件实例对象之间共用一个`data`，产生数据污染。采用函数的形式，`initData`时会将其作为工厂函数都会返回全新`data`对象

### keep-alive

开发中缓存组件使用keep-alive组件，keep-alive是vue内置组件，keep-alive包裹动态组件component时，会缓存不活动的组件实例，而不是销毁它们，这样在组件切换过程中将状态保留在内存中，防止重复渲染DOM。

结合属性include和exclude可以明确指定缓存哪些组件或排除缓存指定组件。vue3中结合vue-router时变化较大，之前是`keep-alive`包裹`router-view`，现在需要反过来用`router-view`包裹`keep-alive`,

```vue
<router-view v-slot="{ Component }">
  <keep-alive>
    <component :is="Component"></component>
  </keep-alive>
</router-view>
```

使用场景：路由动态渲染组件，是否缓存由keep-alive决定

keep-alive内部定义了一个map缓存了创建过的组件实例，本质上执行render函数会在map中找相应的vnode

更新数据可以使用

beforeRouteEnter

actived

### 自定义指令

1. 自定义指令主要完成一些可复用低层级DOM操作
2. 使用自定义指令分为定义、注册和使用三步：
   + 定义自定义指令有两种方式：对象和函数形式，前者类似组件定义，有各种生命周期；后者只会在mounted和updated时执行
   + 注册自定义指令类似组件，可以使用app.directive()全局注册，使用{directives:{xxx}}局部注册
   + 使用时在注册名称前加上v-即可，比如v-focus
3. 我在项目中常用到一些自定义指令，例如：
   + 复制粘贴 v-copy
   + 长按 v-longpress
   + 防抖 v-debounce
   + 图片懒加载 v-lazy
   + 按钮权限 v-premission
   + 页面水印 v-waterMarker
   + 拖拽指令 v-draggable
4. vue3中指令定义发生了比较大的变化，主要是钩子的名称保持和组件一致，这样开发人员容易记忆，不易犯错。另外在v3.2之后，可以在setup中以一个小写v开头方便的定义自定义指令，更简单了！

```vue
// 注册
Vue.directive('my-directive', {
  bind: function () {},
  inserted: function () {},
  update: function () {},
  componentUpdated: function () {},
  unbind: function () {}
})

// 注册 (指令函数)
Vue.directive('my-directive', function () {
  // 这里将会被 `bind` 和 `update` 调用
})

```

### Vue2为什么只有一个根节点

+ `vue2`中组件确实只能有一个根，但`vue3`中组件已经可以多根节点了。
+ 之所以需要这样是因为`vdom`是一颗单根树形结构，`patch`方法在遍历的时候从根节点开始遍历，它要求只有一个根节点。组件也会转换为一个`vdom`，自然应该满足这个要求。
+ `vue3`中之所以可以写多个根节点，是因为引入了`Fragment`的概念，这是一个抽象的节点，如果发现组件是多根的，就创建一个Fragment节点，把多个根节点作为它的children。将来patch的时候，如果发现是一个Fragment节点，则直接遍历children创建或更新。

### Vue3新特性

+ Composition API
+ SFC Composition API语法糖（\<script setup\>）
+ Teleport传送门
+ Fragments片段
+ Emits选项
+ 自定义渲染器
+ SFC CSS变量
+ Suspense

易用性

api简化例如v-model与sync结合，h函数props不再区分属性，特性，事件等

性能

编译期优化，基于proxy的响应系统

扩展性

reactivity模块，customrenderer API等

可维护性

Composition API提高复用性，对TS支持提升

开发体验

新组件等会简化特定场景的代码编写，SFC语法糖

### 动态给vue的data添加一个新属性

`vue2`是用过`Object.defineProperty`实现数据响应式，后增加的属性不是响应式数据

**解决办法**

+ Vue.set()
+ Object.assign()
+ $forcecUpdated()

**Vue.set()**

Vue.set( target, propertyName/index, value )

参数

+ `{Object | Array} target`
+ `{string | number} propertyName/index`
+ `{any} value`

这里无非再次调用`defineReactive`方法，实现新增属性的响应式

**Object.assign()**

直接使用`Object.assign()`添加到对象的新属性不会触发更新

应创建一个新的对象，合并原对象和混入对象的属性

**$forceUpdate**（不建议）

如果你发现你自己需要在 `Vue`中做一次强制更新，99.9% 的情况，是你在某个地方做错了事

`$forceUpdate`迫使`Vue` 实例重新渲染

PS：仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。

### 异步组件

```js
import { defineAsyncComponent } from 'vue'

const AsyncComp = defineAsyncComponent(() => {
  return new Promise((resolve, reject) => {
    // ...从服务器获取组件
    resolve(/* 获取到的组件 */)
  })
})
// ... 像使用其他一般组件一样使用 `AsyncComp`
```

```js
//打包工具实现ES模块动态导入
import { defineAsyncComponent } from 'vue'

const AsyncComp = defineAsyncComponent(() =>
  import('./components/MyComponent.vue')
)
```

1. 在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块
2. 我们不仅可以在路由切换时懒加载组件，还可以在页面组件中继续使用异步组件，从而实现更细的分割粒度。
3. 使用异步组件最简单的方式是直接给defineAsyncComponent 指定一个loader 函数，结合ES模块动态导入函数import可以快速实现。我们甚至可以指定loadingComponent和errorComponent选项从而给用户一个很好的加载皮馈。另外Vue3中还可以结合Suspense组件使用异步组件。
4. 异步组件容易和路由懒加载混淆，实际上不是一个东西。异步组件不能被用于定义懒加载路由上，处理它的是vue框架，处理路由组件加载的是vue-router。但是可以在懒加载的路由组件中使用异步组件。

### Vue错误处理

1. 应用中的错误类型分为”接口异常"和“代码逻辑异常”
2. 我们需要根据不同错误类型做相应处理:接口异常是我们请求后端接口过程中发生的异常，可能是请求失败，也可能是请求获得了服务器响应，但是返回的是错误状态。以Axios为例，这类异常我们可以通过封装Axios，在拦截器中统一处理整个应用中请求的错误。代码逻辑异常是我们编写的前端代码中存在逻辑上的错误造成的异常，vue应用中最常见的方式是使用全局错误处理函数app.config.errorHandler收集错误。
3. 收集到错误之后，需要统一处理这些异常:分析错误，获取需要错误信息和数据。这里应该有效区分错误类型，如果是请求错误，需要上报接口信息，参数，状态码等;对于前端逻辑异常，获取错误名称和详情即可。另外还可以收集应用名称了环境、版本、用户信息，所在页面等。这些信息可以通过vuex存储的全局状态和路由信息获取。

### Vue性能优化

+ 路由懒加载

+ 组件缓存
+ v-show复用DOM，避免重新创建组件（在需要展示的组件很重时）
+ 避免v-if和v-for同时使用
+ v-once和v-memo
+ 长列表性能优化，采用虚拟滚动，只渲染可视区域

+ 事件销毁

+ 图片懒加载
+ 按需引入
+ 子组件分割
+ 服务端渲染、静态网站生成：SSR/SSG

### 简单实现VueRouter

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .component {
      display: none;
    }

    .router-link {
      display: block;
    }
  </style>
</head>

<body>


  <div class="router-link">
    <a href="#/">page1</a>
    <a href="#/page2">page2</a>
  </div>


  <div id="page1" class="component">
    page1
    这是page1的内容
  </div>

  <div id="page2" class="component">
    page2
    这是page2的内容
  </div>
  <script>
    // 定义 Router  
    class Router {
      constructor(rules) {
        this.routes = {};
        this.curUrl = '';
        rules.forEach(item => {
          // console.log(item)
          this.route(item["path"], item["div"])
        });
        this.init()
      }

      route(path, divID) {
        this.routes[path] = divID
      };

      refresh() {
        this.curUrl = window.location.hash.slice(1) || "/";
        // console.log(this.curUrl)
        this.push(this.curUrl)
      };

      push(path) {
        if (this.routes[path]) {
          let divs = document.querySelectorAll(".component")
          divs.forEach(item => {
            item.style.display = "none"
          })
          let div = document.querySelector(`#${this.routes[path]}`)
          div.style.display = "block"
        }
      }

      init() {
        window.addEventListener('load', this.refresh.bind(this), false);
        window.addEventListener('hashchange', this.refresh.bind(this), false);
      }
    }

    // 使用 router  
    window.miniRouter = new Router([
      {
        path: "/",
        div: "page1"
      },
      {
        path: "/page2",
        div: "page2"
      }
    ]);

  </script>
</body>

</html>
```

### route 和 router的区别

简单理解为，**route**是用来获取路由信息的，**router**是用来操作路由的。

#### 一、$route

**1. $route.name**    当前路径名字

**2. $route.meta**    路由元信息

**3. $route.path**    字符串，对应当前路由的路径，总是解析为绝对路径，如"/foo/bar"。

**4.** **$route.hash**    当前路由的hash值 (不带#) ，如果没有 hash 值，则为空字符串。锚点*

**5. $route.query**    一个 key/value 对象，表示 URL 查询参数。例如，对于路径 /foo?user=1，则有$route.query.user == 1，如果没有查询参数，则是个空对象。

**6.** **$route.params**    一个 key/value 对象，包含了 动态片段 和 全匹配片段，如果没有路由参数，就是一个空对象。

**7.** **$route.fullPath**    完成解析后的 URL，包含查询参数和hash的完整路径。

**8.** **$route.matched**    数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。

#### 二、$router

> router是VueRouter的实例，通过Vue.use(VueRouter)和VueRouter构造函数得到一个router的实例对象，这个对象中是一个全局的对象，他包含了所有的路由包含了许多关键的对象和属性  

$router对象是全局路由的实例，是router构造方法的实例

**1. $router.go()**

  $router.back 后退  

  页面路由跳转 \$router.go(-1)为后退，\$router.go(-1)为前进 \$router.forward()为前进

**2.** **$router.push()**

  \- 字符串this.\$router.push('home')

  \- 对象this.\$router.push({path:'home'})

  \- 命名的路由this.\$router.push({name:'user',params:{userId:123}})

  \- 带查询参数，变成 /register?plan=123this.$router.push({path:'register',query:{plan:'123'}})

  \- push方法其实和\<router-link :to="..."\>是等同的。

  *注意：push方法的跳转会向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面。

**3. \$router.replace()**    常用来做404页面

  push方法会向 history 栈添加一个新的记录，而replace方法是替换当前的页面，

  不会向 history 栈添加一个新的记录

  this.\$router.replace('/') 跳转到首页

### 路由懒加载

`const UserDetails = ()=>import('./views/UserDetails ')`

当打包构建应用时，JavaScript包会变得非常大，影响页面加载。利用路由懒加载我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样会更加高效，是一种优化手段。

结合注释`()=>import( /*webpackChunkName: "group-user"*/ './UserDetails.vue')"可以做webpack代码分块，vite中结合rollupOptions定义分块

import来自webpack返回一个promise

路由中不能使用异步组件

### router-link和router-view

+ `vue-router`中两个重要组件`router-link`和`router-view`，分别起到路由导航和组件内容渲染作用
+ `vue-router`会监听`popsgate`事件，点击`router-link`之后页面不会刷新，而是拿出当前path去和routes中path匹配，获得匹配组件之后，`router-view`会将匹配组件渲染出来。
+ `router-link`默认会生成a标签，点击后取消默认跳转行为而是执行一个navigate'方法，它会`pushState`以激活事件处理函数，重新匹配出一个路由`injectedRoute`; `router-view`的渲染函数依赖这个路由，它根据该路由获取要渲染的组件并重新渲染它。

### 完整的导航解析流程

1. 导航被触发。
2. 在失活的组件里调用 `beforeRouteLeave` 守卫。
3. 调用全局的 `beforeEach` 守卫。
4. 在重用的组件里调用 `beforeRouteUpdate` 守卫(2.2+)。
5. 在路由配置里调用 `beforeEnter`。
6. 解析异步路由组件。
7. 在被激活的组件里调用 `beforeRouteEnter`。
8. 调用全局的 `beforeResolve` 守卫(2.5+)。
9. 导航被确认。
10. 调用全局的 `afterEach` 钩子。
11. 触发 DOM 更新。
12. 调用 `beforeRouteEnter` 守卫中传给 `next` 的回调函数，创建好的组件实例会作为回调函数的参数传入。

**记住**参数或查询的改变并不会触发进入/离开的导航守卫**。你可以通过观察 `$route` 对象来应对这些变化，或使用 `beforeRouteUpdate` 的组件内守卫。**

### 路由元信息

```js
meta: { isAuth: true, title: "新闻" },
```

一个路由匹配到的所有路由记录会暴露为 `$route` 对象 (还有在导航守卫中的路由对象) 的 `$route.matched` 数组。因此，我们需要遍历 `$route.matched` 来检查路由记录中的 `meta` 字段。即使用`$route.matched[i].meta`

### Vue-Router传参的方法

+ 动态路由 “/test/:id”  this.$route.params.id

  + ```vue
    <router-link
         :to="{
          name:"test",
          params: {
          id: l.id,
          title: l.title,
          },
        }"
    >{{ l.title }}</router-link>
    ```

  +

+ props:

  + ```js
    {
        name: "xiangqing",
            path: "detail",
                component: Detail,
                    //props第一种写法,该对象中的所有key-value都会以props的形式传给Detail
                    //组件,
                    /* props: {
                    a: 1,
                    b: "hello",
                  }, */
                    //props的第二种写法,若布尔值为真，会把路由收到的所有params参数，以props的形式传给Detail组件
                    // props: true, //不会接受query参数
    
                    //props的第三种写法值为函数,可以接受query参数
                    props($route) {
                    return { id: $route.query.id, title: $route.query.title };
                },
    },
    ```

+ query

  + ```vue
    <router-link
         :to="{
          path: '/home/message/detail',
          query: {
          id: l.id,
          title: l.title,
          },
        }"
    >{{ l.title }}</router-link>
    ```

### Vuex的modules

拆分vuex模块便于维护

getter不会有使用限制

state会使用store.namespace.state

可以使用pinia

### 监听Vuex数据变化

vuex数据状态是响应式的，所以状态变视图跟着变，但是有时还是需要知道数据状态变了从而做一些事情。既然状态都是响应式的，那自然可以`watch`，另外vuex也提供了订阅的API:`store.subscribe()`。

### Vuex的实现

1. 官方说`vuex`是一个状态管理模式和库，并确保这些状态以可预期的方式变更。可见要实现一个'vuex:

+ 要实现一个`Store`存储全局状态
+ 要提供修改状态所需APl:`commit(type，payload)`, `dispatch(type，payload)`

2. 实现`Store`时，可以定义Store类，构造函数接收选项options，设置属性state对外暴露状态，提供commit和dispatch修改属性statq。这里需要设置state为响应式对象，同时将Store定义为一个Vue插件。

3. `commit(type，payload)`方法中可以获取用户传入`mutations`并执行它，这样可以按用户提供的方法修改状态。`dispatch(type，payload）`类似，但需要注意它可能是异步的，需要返回一个Promise给用户以处理异步结果。

## 浏览器

### 跨域的解决方案

#### 跨域（非同源策略请求）

+ 同源策略请求 ajax / fetch
+ 跨域传输

+ xampp 修改本地的host文件

#### 判断是否跨域

+ 协议
+ 域名
+ 端口号
  `三者相同同源，只要有一个不同就是跨域`
  1.JSONP

+ script
+ img
+ link
+ iframe
+ ...
  =>不存在跨域请求的限制

#### 1.jsonp

jsonp需要服务器端的支持（前端传的query中有一个callback函数，后端返回数据为此函数加数据参数）
而且客户端的回调函数必须是全局函数
问题：只能使用get请求
数据不安全

原理

> JSONP实现跨域的原理是利用`script`标签没有跨域限制，通过`src`指向一个`ajax`的URL，最后跟一个回调函数`callback`

#### 2.CORS跨域资源共享

服务器端设置Access-Control-Allow-Origin（请求源） *（就不能携带cookie了）
Access-Control-Allow-Methods（请求方式）
Access-Control-Allow-Credentials(携带cookies等)
Access-Control-Allow-Headers（请求头）
需要处理options试探性请求

#### 3.http proxy => webpack webpack-dev-server

在webpack.config.js的devServer中添加

```js
proxy:{
'/':{
  target: 'http://127.0.0.1:3001',
  changeorigin: true
  }
}
```

#### 4.nginx反向代理=>不需要前端干啥

#### 5.postMessage

A:

```html
<iframe id="iframe" src="http://127.0.0.1:1002/MESSAGE/B.html" frameborder="0" style="display:none; "></iframe>
iframe.onload=function(){
  iframe.contentwindow.postMessage( '珠峰培训',"http://127.0.0.1:1002/");
}
//=>监听B传递的信息
window. onmessage = function (ev) {
  console.log(ev.data) ;
}

```

B:

```js
//=>监听A发送过来的信息
window.onmessage = function (ev) {
  console.log(ev.data) ;
  //=>ev.source:A
  ev.source.postMessage(ev.data+'@@@',ev.origin);|
}
```

#### 6.scoket.io

#### 7.document.domain + iframe

只能实现同一个主域，不同子域之间的操作

```html
<!-- 父页面A -->
<iframe src="http://www.zhufengpeixun.cn/B.html"></iframe>
<script>
document.domain = 'zhufengpeixun.cn' ;
var user = 'admin' ;
</script>


<!-- 子页面B -->
<script>
  document.domain ='zhufengpeixun.cn';
  alert(window.parent.user);
</script>
```

#### 8.window.name + iframe

页面A：

```js
let proxy = function(url, callback) {
    let count = 0;
    let iframe = document.createElement('iframe');
    iframe.src = url;
    iframe.onload = function() {
    if(count==0){
      iframe.contentWindow.location = 'http://www.zhufengpeixun.cn/proxy.html';
      count++;
      return;
    }
    callback(iframe.contentWindow.name);
    };
    document.body.appendChild(iframe) ;
};
```

需要三个页面，两个(A,C)同源(B)一个跨域

#### 9.location.hash + iframe

### CDN

+ 内容分发网络

+ 边缘服务器提供服务
+ CDN网络就是帮服务器近距离给用户分发网页内容的
+ 主要分发静态内容，利用cache-control设置文件缓存形式
+ 流程：源服务器->push->CDN
  + client->request->CDN
  + CDN->response->client
  + 如果没有相应内容CDN->pull->源服务器
+ CDN可以提供时间服务
+ 可以不用担心源服务器DDos服务
+ 负载均衡
+ 利用任播技术，多CDN服务器对外拥有同一个ip地址
+ 使用TLS/SSL证书来进行保护

### http状态码

| 100  | Continue                        | 继续。客户端应继续其请求                                     |
| ---- | ------------------------------- | ------------------------------------------------------------ |
| 101  | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |
|      |                                 |                                                              |
| 200  | OK                              | 请求成功。一般用于GET与POST请求                              |
| 201  | Created                         | 已创建。成功请求并创建了新的资源                             |
| 202  | Accepted                        | 已接受。已经接受请求，但未处理完成                           |
| 203  | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |
| 204  | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
| 205  | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| 206  | Partial Content                 | 部分内容。服务器成功处理了部分GET请求                        |
|      |                                 |                                                              |
| 300  | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| 301  | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| 302  | Found                           | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 303  | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看               |
| 304  | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305  | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                       |
| 306  | Unused                          | 已经被废弃的HTTP状态码                                       |
| 307  | Temporary Redirect              | 临时重定向。与302类似。使用GET请求重定向                     |
|      |                                 |                                                              |
| 400  | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |
| 401  | Unauthorized                    | 请求要求用户的身份认证                                       |
| 402  | Payment Required                | 保留，将来使用                                               |
| 403  | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| 404  | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405  | Method Not Allowed              | 客户端请求中的方法被禁止                                     |
| 406  | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |
| 407  | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |
| 408  | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |
| 409  | Conflict                        | 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 |
| 410  | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |
| 411  | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       |
| 412  | Precondition Failed             | 客户端请求信息的先决条件错误                                 |
| 413  | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |
| 414  | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               |
| 415  | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |
| 416  | Requested range not satisfiable | 客户端请求的范围无效                                         |
| 417  | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |
| 429  |                                 | 请求过于频繁，请求过多                                       |
|      |                                 |                                                              |
| 500  | Internal Server Error           | 服务器内部错误，无法完成请求                                 |
| 501  | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |
| 502  | Bad Gateway                     | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
| 503  | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
| 504  | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
| 505  | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |

### 进程与线程

线程是进程中执行运算的最小单位，是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。

进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。（进程是资源分配的最小单位）
线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）

区别：

（1）调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位

 （2）并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行

 （3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.

 （4）系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销

关系：

（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。

 （2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。

 （3）处理机分给线程，即真正在处理机上运行的是线程。

 （4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。线程是指进程内的一个执行单元,也是进程内的可调度实体.

#### 浏览器进程

浏览器之前为单进程，但现在为多进程，一般分为

+ 渲染进程，将HTML、CSS、Javascript转换为用户可以交互的界面，默认情况下，chrome会为每个Tab标签提供一个渲染进程，渲染进程是运行在沙箱模式下
+ 浏览器主进程，主要负责界面显示、用户交互、子进程管理、提供存储功能等功能
+ 网络进程，负责页面的网络资源加载
+ 插件进程，负责插件的运行，因为插件的易崩溃，所以需要通过插件进程来隔离，已保证插件崩溃时，不会影响浏览器以及其他页面资源
+ GPU进程，chrome的UI界面都选择使用GPU来绘制

**（如果是同一站点，从A页面点到B页面，此时，两个页面同用一个渲染进程，如果两个页面的站点不同，会是两个渲染进程，如果页面中有iframe，iframe也会自己占用一个进程）**

### Cookie、sessionStorage 和localStorage

#### cookie

cookie是服务器端发给客户端的文本文件,但只能储存4kb的数据

cookie的内容主要包括：名字name，值value，过期时间expires，路径path和域domain。路径和域一起构成cookie的作用范围。一般cookie储存在内存里，若设置了过期时间则储存在硬盘里，浏览器页面关闭也不会失效，直到设置的过期时间后才失效。若不设置cookie的过期时间，则有效期为浏览器窗口的会话期间，关闭浏览器窗口就失效。

#### localStorage

localStorage的生命周期是永久，除非手动去清除，否则永远都存在，他的储存大小是5MB，仅在客户端浏览器上储存，不参与服务器的通信。

#### sessionStorage

 sessionStorage顾名思义，是在当前会话下有效，引入了一个“浏览器窗口的概念”,sessionStorage是在同源的同窗口中，始终存在的数据，只要浏览器不关闭，即使是刷新或者进入同源的另一个页面，数据仍在。同时打开“独立”的窗口，即使是同一个页面，sessionStorage的对象也是不同的。关闭窗口后sessionStorage就会被销毁。

#### 区别

1、cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下
2、存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大
3、数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭
4、作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的
5、web Storage支持事件通知机制，可以将数据更新的通知发送给监听者
6、web Storage的api接口使用更方便

### http和https

#### 1.HTTP 和 HTTPS 的基本概念

+ http：是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。
+ https：是以安全为目标的 HTTP 通道，即 HTTP 下加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。

#### 2.HTTP 和 HTTPS 的区别及优缺点

|                 | HTTP                                                     | HTTPS                                                        |
| :-------------: | -------------------------------------------------------- | ------------------------------------------------------------ |
|    安全角度     | 《明⽂传输协议》，是以“明⽂”的⽅式传输数据的             | 《加密传输协议》，传输的数据是需要经过 TLS/SSL 加密后才进行传输的，所以更安全 |
|    端口角度     | 端口：80，基于应用层                                     | 端口：443，基于传输层                                        |
| 加密与证书角度: | 不需要向服务端申请证书                                   | 需要向服务端申请证书，浏览器端安装对应的根证书               |
|      优点       | 简单、灵活、易扩展、应用广                               | 安全性高，确保数据的完整性和准确性                           |
|      缺点       | 内容容易被窃听、篡改、劫持，无法保证数据的完整性和准确性 | 握手时延时较高，部署成本高（占用 CPU 资源）                  |

### 域名解析

+ a）首先会搜索浏览器自身的 DNS 缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存）。
+ b）如果浏览器自身的缓存里面没有找到，那么浏览器会搜索系统自身的 DNS 缓存。
+ c）如果还没有找到，那么尝试从 hosts文件里面去找。
+ d）在前面三个过程都没获取到的情况下，就递归地去域名服务器去查找

### 强缓存和协商缓存

#### 强缓存

强缓存：不会向服务器发送请求，直接从缓存中读取资源。

在 Chrome 中强缓存的请求状态码返回是 200，并且 Size 显示 from disk cache 或 from memory cache 。而在 `Fire Fox`中，`from cache` 状态码是 304，不同浏览器的策略可能有些许不同。

强缓存可以通过设置两种 HTTP Header 实现：**Expires** 和 **Cache-Control。两者同时存在的话，Cache-Control优先级高于Expires。**强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，所以就可能会导致加载文件不是服务器端最新的内容。

##### Expires

缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。

Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。比如：`Expires: Wed, 22 Oct 2018 08:41:00 GMT`表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。

`Expires` 是 `http 1.0` 的规范，值是一个`GMT` 格式的时间点字符串，比如 `Expires:Mon,18 Oct 2066 23:59:59 GMT` 。这个时间点代表资源失效的时间，如果当前的时间戳在这个时间之前，则判定命中缓存。有一个缺点是，失效时间是一个绝对时间，如果服务器时间与客户端时间偏差较大时，就会导致缓存混乱。而服务器的时间跟用户的实际时间是不一样是很正常的，所以 `Expires` 在实际使用中会带来一些麻烦。

##### Cache-Control

在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当`Cache-Control:max-age=300`时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。如果 `Cache-Control`与 `Expires` 同时存在的话， `Cache-Control` 的优先级高于 `Expires` 。

`Cache-Control`这个字段是 `http 1.1` 的规范，一般常用该字段的 `max-age` 值来进行判断，它是一个相对时间，比如 .`Cache-Control:max-age=3600` 代表资源的有效期是 3600 秒。并且返回头中的 `Date` 表示消息发送的时间，表示当前资源在 `Date ~ Date +3600s` 这段时间里都是有效的。不过我在实际使用中常常遇到设置了 `max-age` 之后，在 `max-age` 时间内重新访问资源却会返回 `304 not modified` ，这是由于服务器的时间与本地的时间不同造成的。

+ **public：所有内容都将被缓存（客户端和代理服务器都可缓存）。**具体来说响应可被任何中间节点缓存，如 Browser <-- proxy1 <-- proxy2 <-- Ser，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给 Browser 而不再向proxy2要。

+ **private：所有内容只有客户端可以缓存**，**中间节点不允许缓存。**Cache-Control的默认取值。具体来说，对于Browser <-- proxy1 <-- proxy2 <-- Server，proxy 会老老实实把Server 返回的数据发送给proxy1，自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。

+ **no-cache：**客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control的缓存控制方式做前置验证，而是**使用 Etag 或者Last-Modified字段来控制缓存**。需要注意的是，no-cache这个名字有一点误导。**设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。**
+ **no-store：**所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
+ **max-age：**max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效

+ **s-maxage**（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。**s-maxage的优先级高于max-age**。如果存在s-maxage，则会覆盖掉max-age和Expires header。
+ **max-stale**：能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。
+ **min-fresh**：能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。

##### Expires和Cache-Control的区别

其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，**两者同时存在的话，Cache-Control优先级高于Expires**；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。

#### 协商缓存

强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容。此时我们可以使用协商缓存策略。

协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。协商缓存可以通过设置两种 HTTP Header 实现：**Last-Modified** 和 **ETag** 。服务器校验优先考虑Etag。

协商缓存时请求的响应状态码是 304

协商缓存生效和失效的请求过程示意图：

+ 协商缓存失效，返回 304 和 Not Modified：

![img](../images/xshc1.png)

+ 协商缓存失效，返回200和请求结果：

![img](../images/xshc2.png)

##### Last-Modified（If-Modified-Since）

浏览器在第一次访问资源时，服务器在返回资源的同时，会自动在 response header 中添加 Last-Modified 的响应头，值是这个资源在服务器上的最后修改时间，浏览器接收后会将该文件响应头 Last-Modified 缓存起来。

在浏览器下一次请求该资源时，浏览器检测到有 Last-Modified 这个header，会自动往请求头中添加 If-Modified-Since ，值就是 Last-Modified 中的值

服务器再次收到这个资源请求时，会自动根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比。如果没有变化，则返回 304 和 空 的响应体，浏览器会直接从缓存读取该资源。如果 If-Modified-Since 的时间小于服务器中这个资源的最后修改时间，说明文件有更新，服务器会返回新的资源文件和 200。

Last-Modified 存在一些弊端：

+ 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源
+ 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源

##### ETag（If-None-Match）

根据文件修改时间来决定是否缓存尚有不足，我们可以直接根据文件内容是否修改来决定缓存策略，也就是使用 ETag。``

**Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。**浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的 Etag 值放到 request header 里的 If-None-Match 里，服务器只需要比较客户端传来的If-None-Match 跟自己服务器上该资源的 ETag 是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200 回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。

##### Last-Modified和ETag的对比

+ 首先在精确度上，Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。

+ 第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。
+ 第三在优先级上，服务器校验优先考虑Etag

### script 加载外部代码

#### defer 属性

为了解决脚本文件下载阻塞网页渲染的问题，一个方法是对`<script>`元素加入`defer`属性。它的作用是延迟脚本的执行，等到 DOM 加载生成后，再执行脚本。

#### async 属性

解决“阻塞效应”的另一个方法是对`<script>`元素加入`async`属性。

`async`属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。

1. 浏览器开始解析 HTML 网页。
2. 解析过程中，发现带有`async`属性的`script`标签。
3. 浏览器继续往下解析 HTML 网页，同时并行下载`<script>`标签中的外部脚本。
4. 脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本。
5. 脚本执行完毕，浏览器恢复解析 HTML 网页。

另外，使用`async`属性的脚本文件里面的代码，不应该使用`document.write`方法。

### 浏览器组成

浏览器的核心是两部分：渲染引擎和 JavaScript 解释器（又称 JavaScript 引擎）。

#### 渲染引擎

渲染引擎的主要作用是，将网页代码渲染为用户视觉可以感知的平面文档。

不同的浏览器有不同的渲染引擎。

+ Firefox：Gecko 引擎
+ Safari：WebKit 引擎
+ Chrome：Blink 引擎
+ IE: Trident 引擎
+ Edge: EdgeHTML 引擎

渲染引擎处理网页，通常分成四个阶段。

1. 解析代码：HTML 代码解析为 DOM，CSS 代码解析为 CSSOM（CSS Object Model）。
2. 对象合成：将 DOM 和 CSSOM 合成一棵渲染树（render tree）。
3. 布局：计算出渲染树的布局（layout）。
4. 绘制：将渲染树绘制到屏幕。

以上四步并非严格按顺序执行，往往第一步还没完成，第二步和第三步就已经开始了。所以，会看到这种情况：网页的 HTML 代码还没下载完，但浏览器已经显示出内容了。

#### JavaScript引擎

JavaScript 引擎的主要作用是，读取网页中的 JavaScript 代码，对其处理后运行。

### URL实例属性

URL 实例的属性与`Location`对象的属性基本一致，返回当前 URL 的信息。

+ URL.href：返回整个 URL
+ URL.protocol：返回协议，以冒号`:`结尾
+ URL.hostname：返回域名
+ URL.host：返回域名与端口，包含`:`号，默认的80和443端口会省略
+ URL.port：返回端口
+ URL.origin：返回协议、域名和端口
+ URL.pathname：返回路径，以斜杠`/`开头
+ URL.search：返回查询字符串，以问号`?`开头
+ URL.searchParams：返回一个`URLSearchParams`实例，该属性是`Location`对象没有的
+ URL.hash：返回片段识别符，以井号`#`开头
+ URL.password：返回域名前面的密码
+ URL.username：返回域名前面的用户名

```js
var url = new URL('http://user:passwd@www.example.com:4097/path/a.html?x=111#part1');

url.href
// "http://user:passwd@www.example.com:4097/path/a.html?x=111#part1"
url.protocol
// "http:"
url.hostname
// "www.example.com"
url.host
// "www.example.com:4097"
url.port
// "4097"
url.origin
// "http://www.example.com:4097"
url.pathname
// "/path/a.html"
url.search
// "?x=111"
url.searchParams
// URLSearchParams {}
url.hash
// "#part1"
url.password
// "passwd"
url.username
// "user"
```

### URLSearchParams对象

+ URLSearchParams 对象

  + 概述

  + URLSearchParams.toString()

    + `toString`方法返回实例的字符串形式。

  + URLSearchParams.append()

    + `append()`方法用来追加一个查询参数。它接受两个参数，第一个为键名，第二个为键值，没有返回值。

  + URLSearchParams.delete()

    + `delete()`方法用来删除指定的查询参数。它接受键名作为参数。

  + URLSearchParams.has()

    + `has()`方法返回一个布尔值，表示查询字符串是否包含指定的键名。

  + URLSearchParams.set()

    + `set()`方法用来设置查询字符串的键值。

      它接受两个参数，第一个是键名，第二个是键值。

  + URLSearchParams.get()，URLSearchParams.getAll()

    + `get()`方法用来读取查询字符串里面的指定键。它接受键名作为参数。

  + URLSearchParams.sort()

    + `sort()`方法对查询字符串里面的键进行排序，规则是按照 Unicode 码点从小到大排列。

+ 这三个方法都返回一个遍历器对象，供`for...of`循环遍历

  + URLSearchParams.keys(),
  + URLSearchParams.values()，
  + URLSearchParams.entries()

### ArrayBuffer对象

ArrayBuffer 对象表示一段二进制数据，用来模拟内存里面的数据。通过这个对象，JavaScript 可以读写二进制数据。这个对象可以看作内存数据的表达。

+ ArrayBuffer 对象有实例属性`byteLength`，表示当前实例占用的内存长度（单位字节）。
+ ArrayBuffer 对象有实例方法`slice()`，用来复制一部分内存。它接受两个整数参数，分别表示复制的开始位置（从0开始）和结束位置（复制时不包括结束位置）

### Blob对象

`Blob`构造函数接受两个参数。第一个参数是数组，成员是字符串或二进制对象，表示新生成的`Blob`实例对象的内容；第二个参数是可选的，是一个配置对象，目前只有一个属性`type`，它的值是一个字符串，表示数据的 MIME 类型，默认是空字符串。

+ `Blob`具有两个实例属性`size`和`type`，分别返回数据的大小和类型。
+ `Blob`具有一个实例方法`slice`，用来拷贝原来的数据，返回的也是一个`Blob`实例

文件选择器返回一个 FileList 对象，该对象是一个类似数组的成员，每个成员都是一个 File 实例对象。File 实例对象是一个特殊的 Blob 实例，增加了`name`和`lastModifiedDate`属性。

浏览器允许使用`URL.createObjectURL()`方法，针对 Blob 对象生成一个临时 URL，以便于某些 API 使用。这个 URL 以`blob://`开头，表明对应一个 Blob 对象，协议头后面是一个识别符，用来唯一对应内存里面的 Blob 对象。这一点与`data://URL`（URL 包含实际数据）和`file://URL`（本地文件系统里面的文件）都不一样。

取得 Blob 对象以后，可以通过`FileReader`对象，读取 Blob 对象的内容，即文件内容。

FileReader 对象提供四个方法，处理 Blob 对象。Blob 对象作为参数传入这些方法，然后以指定的格式返回。

+ `FileReader.readAsText()`：返回文本，需要指定文本编码，默认为 UTF-8。
+ `FileReader.readAsArrayBuffer()`：返回 ArrayBuffer 对象。
+ `FileReader.readAsDataURL()`：返回 Data URL。
+ `FileReader.readAsBinaryString()`：返回原始的二进制字符串。

### 内存泄漏

+ 未清除定时器

+ 变量未释放

+ 变量引用->尝试使用WeakMap、WeakSet等结构

+ 未被销毁的事件监听

+ DOM引用

+ 意外的全局变量

+ 闭包

### 浏览器输入url并回车后会发送什么

先查询浏览器缓存->有就直接返回ip，没有查询电脑hosts文件，还没有就向dns服务器发送查询，获取ip地址->建立连接(三次握手)->获取数据->四次挥手

`chrome://net-internals/#dns`

### 浏览器渲染进程

+ html->dom树，同时css->css结构体（并行）
+ 进入render tree（渲染树）
+ 计算布局信息
+ UI引擎渲染
+ 呈现页面

### 性能优化

+ 加载
  + 减少http请求（精灵图，文件合并）
  + 减小文件大小（资源压缩，图片压缩，代码压缩）
  + CDN（第三方库，大文件链接引入）
  + SSR服务端渲染，预渲染
  + 懒加载
  + 分包
+ 减少dom操作，避免回流，文档碎片

**真正的性能优化**

+ 页面加载性能（加载时间，用户体验）
+ 动画和操作性能（是否流畅无卡顿）
+ 电量消耗（游戏方面）
+ 内存占用（内存占用过大，浏览器崩掉）

**技术方案划分**

+ 缓存 客户端强缓存
+ 降低请求成本
+ 减少请求次数
+ 减少传输体积

### token能放在cookie中吗？

能、不设置cookie有效期、重新登录重写cookie覆盖原来的cookie 标准回答 能。 token一般是用来判断用户是否登录的，它内部包含的信息有：uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串） `token`可以存放在`Cookie`中，`token` 是否过期，应该由后端来判断，不该前端来判断，所以`token`存储在`cookie`中只要不设置`cookie`的过期时间就ok了，如果 `token` 失效，就让后端在接口中返回固定的状态表示`token` 失效，需要重新登录，再重新登录的时候，重新设置 `cookie` 中的 `token` 就行。 加分回答 token认证流程 1. 客户端使用用户名跟密码请求登录 2. 服务端收到请求，去验证用户名与密码 3. 验证成功后，服务端签发一个 token ，并把它发送给客户端 4. 客户端接收 token 以后会把它存储起来，比如放在 cookie 里或者 localStorage 里 5. 客户端每次发送请求时都需要带着服务端签发的 token（把 token 放到 HTTP 的 Header 里） 6. 服务端收到请求后，需要验证请求里带有的 token ，如验证成功则返回对应的数据

### 常见请求头和响应头

1)请求(客户端->服务端[request])
  GET(请求的方式) /newcoder/hello.html(请求的目标资源) HTTP/1.1(请求采用的协议和版本号)
  Accept: */*(客户端能接收的资源类型)
  Accept-Language: en-us(客户端接收的语言类型)
  Connection: Keep-Alive(维护客户端和服务端的连接关系)
  Host: localhost:8080(连接的目标主机和端口号)
  Referer: <http://localhost/links.asp>(告诉服务器我来自于哪里)
  User-Agent: Mozilla/4.0(客户端版本号的名字)
  Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型)
  If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT(缓存时间)
  Cookie(客户端暂存服务端的信息)

  Date: Tue, 11 Jul 2000 18:23:51 GMT(客户端请求服务端的时间)

2)响应(服务端->客户端[response])
  HTTP/1.1(响应采用的协议和版本号) 200(状态码) OK(描述信息)
  Location: <http://www.baidu.com>(服务端需要客户端访问的页面路径)
  Server:apache tomcat(服务端的Web服务端名)
  Content-Encoding: gzip(服务端能够发送压缩编码类型)
  Content-Length: 80(服务端发送的压缩数据的长度)
  Content-Language: zh-cn(服务端发送的语言类型)
  Content-Type: text/html; charset=GB2312(服务端发送的类型及采用的编码方式)
  Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT(服务端对该资源最后修改的时间)
  Refresh: 1;url=<http://www.it315.org(服务端要求客户端1>秒钟后，刷新，然后访问指定的页面路径)
  Content-Disposition: attachment; filename=aaa.zip(服务端要求客户端以下载文件的方式打开该文件)
  Transfer-Encoding: chunked(分块传递数据到客户端）  
  Set-Cookie:SS=Q0=5Lb_nQ; path=/search(服务端发送到客户端的暂存数据)
  Expires: -1//3种(服务端禁止客户端缓存页面数据)
  Cache-Control: no-***(服务端禁止客户端缓存页面数据)  
  Pragma: no-***(服务端禁止客户端缓存页面数据)  
  Connection: close(1.0)/(1.1)Keep-Alive(维护客户端和服务端的连接关系)  

  Date: Tue, 11 Jul 2000 18:23:51 GMT(服务端响应客户端的时间)

**在服务器响应客户端的时候，带上Access-Control-Allow-Origin头信息，解决跨域的一种方法。**

### 网络安全

#### XSS

跨站脚本攻击，英文全称是Cross Site Script，本来缩写是CSS，但是为了和层叠样式表（Cas-cading Style Sheet，CSS）有所区别，所以在安全领域叫做“XSS”。

XSS根据效果的不同可以分成如下几类。

第一种类型：反射型XSS

反射型XSS只是简单地把用户输入的数据“反射”给浏览器。也就是说，黑客往往需要诱使用户“点击”一个恶意链接，才能攻击成功。反射型XSS也叫做“非持久型XSS”（Non-persistent XSS）。

第二种类型：存储型XSS

存储型XSS会把用户输入的数据“存储”在服务器端。这种XSS具有很强的稳定性。

第三种类型：DOM Based XSS

实际上，这种类型的XSS并非按照“数据是否保存在服务器端”来划分，DOM Based XSS从效果上来说也是反射型XSS。单独划分出来，是因为DOM Based XSS的形成原因比较特别，发现它的安全专家专门提出了这种类型的XSS。出于历史原因，也就把它单独作为一个分类了。

通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS。

#### 跨站点请求伪造（CSRF）

CSRF的全名是Cross Site RequestForgery，翻译成中文就是跨站点请求伪造。它是一种常见的Web攻击

利用发送cookie伪造请求

HTTP请求，Cookie的使用过程：

1、server通过HTTP Response中的"Set-Cookie: header"把cookie发送给client

2、client把cookie通过HTTP Request 中的“Cookie: header”发送给server

3、每次HTTP请求，Cookie都会被发送。

HTTP请求发送Cookies的条件：

1、本地已经缓存有cookies

2、根据请求的URL来匹配cookies的domain、path属性，如果都符合才会发送。

举个例子：访问www.baidu.com时，就不发送www.qq.com的cookies.

Chrome 51 开始，浏览器的 Cookie 新增加了一个`SameSite`属性，用来防止 CSRF 攻击和用户追踪。

#### 点击劫持（ClickJacking）

**是什么**

点击劫持是一种视觉上的欺骗手段。攻击者使用一个透明的、不可见的iframe，覆盖在一个网页上，然后诱使用户在该网页上进行操作，此时用户将在不知情的情况下点击透明的iframe页面。通过调整iframe页面的位置，可以诱使用户恰好点击在iframe页 面的一些功能性按钮上。

**图片覆盖攻击（XSIO）**

通过调整图片的style使得图片能够覆盖在他所指定的任意位置

**拖拽劫持与数据窃取**

“拖拽劫持”的思路是诱使用户从隐藏的不可见iframe中“拖拽”出攻击者希望得到的数据，然后放到攻击者能控制的另外一个页面中，从而窃取数据

**ClickJacking 3.0：触屏劫持（TapJacking）**

通过将一个不可见的iframe覆盖到当前网页上，可以劫持用户的触屏操作

#### HTML5新标签

+ HTML 5定义了很多新标签、新事件，这有可能带来新的XSS攻击。
+ 专门为iframe定义了一个新的属性，叫sandbox。
+ sandbox属性可以通过参数来支持更精确的控制。有以下几个值可以选择：
  + allow-same-origin：允许同源访问；
  + allow-top-navigation：允许访问顶层窗口；
  + allow-forms：允许提交表单；
  + allow-scripts：允许执行脚本。
  + 可有的行为即便是设置了allow-scripts，也是不允许的，比如“弹出窗口”
+ Link Types: noreferrer `<a href="xxx" rel="noreferrer" >test</a>`
  + 标签指定了noreferrer后，浏览器在请求该标签指定的地址时将不再发送Referer
+ Canvas的妙用，可以绕过验证码

#### 其他安全问题

+ Cross-Origin Resource Sharing
+ postMessage——跨窗口传递
  + 在使用postMessage()时，有两个安全问题需要注意。
    + 在必要时，可以在接收窗口验证 Domain，甚至验证URL，以防止来自非法页面的消息。这实际上是在代码中实现一次同源策略的验证过程。
    + 接收的消息写入textContent，但在实际应用中，如果将消息写入innerHTML，甚至直接写入script中，则可能会导致DOMbased XSS的产生。根据“Secure By Default”原则，在接收窗口不应该信任接收到的消息，而需要对消息进行安全检查。
+ Web Storage

## 面试题

```js
var status = '1'
setTimeout(() => {
    const status = '2'
    const data = {
        status: "3",
        getStatus() {
            console.log(this)
            return this.status
        }
    }
    console.log(data.getStatus())//3
    console.log(data.getStatus.call(this))//1
}, 0)
```

```js
const pipeFunctions = (...fns) => {
    return fns.reduce((preFn, curFn) => {
        return (...args) => {
            const res = preFn(...args)
            return curFn(res)
        }
    })
}
const add = x => x + 5;
const multiply = (x) => x * 5;
const subtraction = x => x - 5;
const division = x => x / 5;
const targetFn = pipeFunctions(add,
                               multiply,
                               subtraction,
                               division)
console.log(targetFn(5));



//异步
const pipeFunctions2 = (...fns) => {
    return fns.reduce((preFn, curFn) => {
        return async (...args) => {
            const res = await preFn(...args);
            return curFn(res);
        }
    })
}

const asyncFn = (v) => {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve(v);
        }, Math.random() * 1000);
    });
};

const add2 = async x => await asyncFn(x + 5);
const multiply2 = async (x) => await asyncFn(x * 5);
const subtraction2 = async x => await asyncFn(x - 5);
const division2 = async x => await asyncFn(x / 5);
const targetFn2 = pipeFunctions2(add2,
                                 multiply2,
                                 subtraction2,
                                 division2)
targetFn2(5).then((res) => {
    console.log(res)
}, (err) => {
    console.log(err)
})
```

```JS
let a={value:1}
a.valueOf=function(){
  return a.value++
}
console.log(a==1&&a==2&&a==3)
```

```js
function add() {
    // 第一次执行时，定义一个数组专门用来存储所有的参数
    var _args = Array.prototype.slice.call(arguments);

    // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值
    var _adder = function() {
        _args.push(...arguments);
        return _adder;
    };
    
    // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回
    _adder.toString = function () {
        return _args.reduce(function (a, b) {
            return a + b;
        });
    }
    return _adder;
}
console.log(add(1)(2))
```

## TypeScript

![Types](../images/TypeScript%20Types.png)

![Class](../images/TypeScript%20Classes.png)

![Interface](../images/TypeScript%20Interfaces.png)

![Control](../images/TypeScript%20Control%20Flow%20Analysis.png)

## Webpack

### 模式选择

| **选项**    | **描述**                                              |
| ----------- | ----------------------------------------------------- |
| development | 开发模式，打包更加快速，省了代码优化步骤              |
| production  | 生产模式，打包比较慢，会开启 tree-shaking 和 压缩代码 |
| none        | 不使用任何默认优化选项                                |

### 基本配置

```js
const path = require('path')

module.exports = {
  mode: 'development', // 模式
  entry: './src/index.js', // 打包入口地址
  output: {
    filename: 'bundle.js', // 输出文件名
    path: path.join(__dirname, 'dist') // 输出文件目录
  }
}
```

### html-webpack-plugin

如果我想打包后的资源文件，例如：js 或者 css 文件可以自动引入到 Html 中，就需要使用插件 [html-webpack-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fhtml-webpack-plugin)来帮助你完成这个操作

### clean-webpack-plugin

这里我们可以使用插件 [clean-webpack-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fclean-webpack-plugin) 来实现

### cross-env

针对不同的需求，首先要做的就是做好环境的区分

```js
console.log('process.env.NODE_ENV=', process.env.NODE_ENV) // 打印环境变量
```

### webpack-dev-server

**为什么要配置 contentBase ？**

因为 webpack 在进行打包的时候，对静态文件的处理，例如图片，都是直接 copy 到 dist 目录下面。但是对于本地开发来说，这个过程太费时，也没有必要，所以在设置 contentBase 之后，就直接到对应的静态目录下面去读取文件，而不需对文件做任何移动，节省了时间和性能开销。

启动本地服务器

### style-loader

style-loader 就是将处理好的 css 通过 style 标签的形式添加到页面上

### postcss-loader

使用 [postcss-loader](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Floaders%2Fpostcss-loader%2F)，自动添加 CSS3 部分属性的浏览器前缀

上面我们用到的 `transform: translateX(-50%);`，需要加上不同的浏览器前缀，这个我们可以使用 postcss-loader 来帮助我们完成

### mini-css-extract-plugin

分离样式文件

前面，我们都是依赖 `style-loader` 将样式通过 style 标签的形式添加到页面上

但是，更多时候，我们都希望可以通过 CSS 文件的形式引入到页面上

### 图片资源打包

| **Loader**  | **Loader**                                                   |
| ----------- | ------------------------------------------------------------ |
| file-loader | 解决图片引入问题，并将图片 copy 到指定目录，默认为 dist      |
| url-loader  | 解依赖 file-loader，当图片小于 limit 值的时候，会将图片转为 base64 编码，大于 limit 值的时候依然是使用 file-loader 进行拷贝 |
| img-loader  | 压缩图片                                                     |

现在 Webpack5 已经将两个 Loader 功能内置到 Webpack 里了，我们只需要简单配置即可处理图片资源

```js
{
    test: /\.(png|jpe?g|gif|webp|svg)$/,
        type: 'asset',
            parser: {
                dataUrlCondition: {
                    // 小于10kb转base64
                    // 减少请求数量，体积会变大一点
                    maxSize: 10 * 1024 // 10kb
                }
            },
                generator: {
                    //输出图片名称 :10代表取前十位hash值
                    filename: 'static/images/[hash:10][ext][query]'
                }
}
```

```js
// main.js
import "./css/iconfont.css"

// webpack.config.js
{
  test: /\.(ttf|woff2?)$/,
  type: 'asset/resource',
  generator: {
    //输出名称 
    filename: 'static/media/[hash:10][ext][query]'
  }
}
```

直接输出

```js
type: 'asset/resource',
```

#### 资源模块的使用

> webpack5 新增资源模块(asset module)，允许使用资源文件（字体，图标等）而无需配置额外的 loader。

资源模块支持以下四个配置：

> 1. `asset/resource` 将资源分割为单独的文件，并导出 url，类似之前的 file-loader 的功能.
> 2. `asset/inline` 将资源导出为 dataUrl 的形式，类似之前的 url-loader 的小于 limit 参数时功能.
> 3. `asset/source` 将资源导出为源码（source code）. 类似的 raw-loader 功能.
> 4. `asset` 会根据文件大小来选择使用哪种类型，当文件小于 8 KB（默认） 的时候会使用 asset/inline，否则会使用 asset/resource

### babel

在开发中我们想使用最新的 Js 特性，但是有些新特性的浏览器支持并不是很好，所以 Js 也需要做兼容处理，常见的就是将 ES6 语法转化为 ES5。

这里将登场的“全场最靓的仔” -- Babel

+ `babel-loader` 使用 Babel 加载 ES2015+ 代码并将其转换为 ES5
+ `@babel/core` Babel 编译的核心包
+ `@babel/preset-env` Babel 编译的预设，可以理解为 Babel 插件的超集

```js
// ./babelrc.js

module.exports = {
  presets: [
    [
      "@babel/preset-env",
      {
        // useBuiltIns: false 默认值，无视浏览器兼容配置，引入所有 polyfill
        // useBuiltIns: entry 根据配置的浏览器兼容，引入浏览器不兼容的 polyfill
        // useBuiltIns: usage 会根据配置的浏览器兼容，以及你代码中用到的 API 来进行 polyfill，实现了按需添加
        useBuiltIns: "entry",
        corejs: "3.9.1", // 是 core-js 版本号
        targets: {
          chrome: "58",
          ie: "11",
        },
      },
    ],
  ],
};
```

对于正在提案中，还未进入 ECMA 规范中的新特性，Babel 是无法进行处理的，必须要安装对应的插件

怎么才能使用呢？Babel 其实提供了对应的插件：

+ `@babel/plugin-proposal-decorators`
+ `@babel/plugin-proposal-class-properties`

### SourceMap 配置选择

SourceMap 是一种映射关系，当项目运行后，如果出现错误，我们可以利用 SourceMap 反向定位到源码位置

#### devtool

```js
devtool: 'source-map',
```

**`eval` 模式：**

1. 生成代码通过 **`eval`** 执行
2. 源代码位置通过 **`@sourceURL`** 注明
3. 无法定位到错误位置，只能定位到**某个文件**
4. 不用生成 SourceMap 文件，**打包速度快**

**`source-map` 模式：**

1. 生成了对应的 SourceMap 文件，**打包速度慢**
2. 在**源代码**中定位到错误所在**行列**信息

**`eval-source-map` 模式：**

1. 生成代码通过 **`eval` 执行**
2. 包含 **dataUrl** 形式的 SourceMap 文件
3. 可以在**编译后**的代码中定位到错误所在**行列**信息
4. 生成 dataUrl 形式的 SourceMap，打包速度慢

**`eval-cheap-source-map` 模式：**

1. 生成代码通过 **`eval` 执行**
2. 包含 **dataUrl** 形式的 SourceMap 文件
3. 可以在**编译后**的代码中定位到错误所在**行**信息
4. 不需要定位列信息，打包**速度较快**

**`eval-cheap-module-source-map` 模式：**

1. 生成代码通过 **`eval`** 执行
2. 包含 **dataUrl** 形式的 SourceMap 文件
3. 可以在**编译后**的代码中定位到错误所在**行**信息
4. 不需要定位列信息，打包**速度较快**
5. 在**源代码**中定位到错误所在**行**信息

**`inline-source-map` 模式：**

1. 通过 **dataUrl** 的形式引入 SourceMap 文件... 余下和 `source-map` 模式一样

**`hidden-source-map` 模式：**

1. 看不到 SourceMap 效果，但是生成了 SourceMap 文件

**`nosources-source-map` 模式：**

1. 能看到错误出现的位置
2. 但是没有办法现实对应的源码

总结：

| devtool                      | build | rebuild       | 显示代码 | SourceMap 文件 | 描述         |
| ---------------------------- | ----- | ------------- | -------- | -------------- | ------------ |
| (none)                       | 很快  | 很快          | 无       | 无             | 无法定位错误 |
| eval                         | 快    | 很快（cache） | 编译后   | 无             | 定位到文件   |
| source-map                   | 很慢  | 很慢          | 源代码   | 有             | 定位到行列   |
| eval-source-map              | 很慢  | 一般（cache） | 编译后   | 有（dataUrl）  | 定位到行列   |
| eval-cheap-source-map        | 一般  | 快（cache）   | 编译后   | 有（dataUrl）  | 定位到行     |
| eval-cheap-module-source-map | 慢    | 快（cache）   | 源代码   | 有（dataUrl）  | 定位到行     |
| inline-source-map            | 很慢  | 很慢          | 源代码   | 有（dataUrl）  | 定位到行列   |
| hidden-source-map            | 很慢  | 很慢          | 源代码   | 有             | 无法定位错误 |
| nosource-source-map          | 很慢  | 很慢          | 源代码   | 无             | 定位到文件   |

对照一下校验规则 `^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$` 分析一下关键字

| 关键字    | 描述                                                      |
| --------- | --------------------------------------------------------- |
| inline    | 代码内通过 dataUrl 形式引入 SourceMap                     |
| hidden    | 生成 SourceMap 文件，但不使用                             |
| eval      | `eval(...)` 形式执行代码，通过 dataUrl 形式引入 SourceMap |
| nosources | 不生成 SourceMap                                          |
| cheap     | 只需要定位到行信息，不需要列信息                          |
| module    | 展示源代码中的错误位置                                    |

### hash

### 三种 hash 值

Webpack 文件指纹策略是将文件名后面加上 hash 值。特别在使用 CDN 的时候，缓存是它的特点与优势，但如果打包的文件名，没有 hash 后缀的话，你肯定会被缓存折磨的够呛

例如我们在基础配置中用到的：`filename: "[name][hash:8][ext]"`

这里里面 `[]` 包起来的，就叫占位符

| 占位符      | 解释                       |
| ----------- | -------------------------- |
| ext         | 文件后缀名                 |
| name        | 文件名                     |
| path        | 文件相对路径               |
| folder      | 文件所在文件夹             |
| hash        | 每次构建生成的唯一 hash 值 |
| chunkhash   | 根据 chunk 生成 hash 值    |
| contenthash | 根据文件内容生成hash 值    |

表格里面的 `hash`、`chunkhash`、`contenthash` 你可能还是不清楚差别在哪

+ **hash** ：任何一个文件改动，整个项目的构建 hash 值都会改变；
+ **chunkhash**：文件的改动只会影响其所在 chunk 的 hash 值；
+ **contenthash**：每个文件都有单独的 hash 值，文件的改动只会影响自身的 hash 值

### 优化

#### 优化 resolve 配置

##### 1.2.1 alias

alias 用的创建 `import` 或 `require` 的别名，用来简化模块引用，项目中基本都需要进行配置。

##### 1.2.2 extensions

webpack 默认配置

```js
const config = {
  //...
  resolve: {
    extensions: ['.js', '.json', '.wasm'],
  },
};
```

如果用户引入模块时不带扩展名，例如

```js
import file from '../path/to/file';
```

那么 webpack 就会按照 extensions 配置的数组从左到右的顺序去尝试解析模块

需要注意的是：

1. 高频文件后缀名放前面；
2. 手动配置后，默认配置会被覆盖

如果想保留默认配置，可以用 `...` 扩展运算符代表默认配置

##### 1.2.3 modules

告诉 webpack 解析模块时应该搜索的目录，常见配置如下

```js
const path = require('path');

// 路径处理方法
function resolve(dir){
  return path.join(__dirname, dir);
}

const config = {
  //...
  resolve: {
     modules: [resolve('src'), 'node_modules'],
  },
};
复制代码
```

告诉 webpack 优先 src 目录下查找需要解析的文件，会大大节省查找时间

##### 1.2.4 resolveLoader

resolveLoader 与上面的 resolve 对象的属性集合相同， 但仅用于解析 webpack 的 [loader](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fconcepts%2Floaders) 包。

**一般情况下保持默认配置就可以了，但如果你有自定义的 Loader 就需要配置一下**，不配可能会因为找不到 loader 报错

#### 1.3 externals

`externals` 配置选项提供了「**从输出的 bundle 中排除依赖**」的方法。此功能通常对 **library 开发人员**来说是最有用的，然而也会有各种各样的应用程序用到它。

例如，从 CDN 引入 jQuery，而不是把它打包

1. 引入链接

```html
<script
  src="https://code.jquery.com/jquery-3.1.0.js"
  integrity="sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk="
  crossorigin="anonymous"
></script>
```

1. 配置 externals

```js
const config = {
  //...
  externals: {
    jquery: 'jQuery',
  },
};
```

1. 使用 jQuery

```js
import $ from 'jquery';

$('.my-element').animate(/* ... */);
```

我们可以用这样的方法来剥离不需要改动的一些依赖，大大节省打包构建的时间

#### 缩小范围

在配置 loader 的时候，我们需要更精确的去指定 loader 的作用目录或者需要排除的目录，通过使用 `include` 和 `exclude` 两个配置项，可以实现这个功能，常见的例如：

+ **`include`**：符合条件的模块进行解析
+ **`exclude`**：排除符合条件的模块，不解析
+ **`exclude`** 优先级更高

#### noParse

+ 不需要解析依赖的第三方大型类库等，可以通过这个字段进行配置，以提高构建速度
+ 使用 noParse 进行忽略的模块文件中不会解析 `import`、`require` 等语法

#### 多进程配置

> **注意**：实际上在小型项目中，开启多进程打包反而会增加时间成本，因为启动进程和进程间通信都会有一定开销。

##### 1.5.1 thread-loader

配置在 [thread-loader](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Floaders%2Fthread-loader%2F%23root) 之后的 loader 都会在一个单独的 worker 池（worker pool）中运行

1. 安装

```bash
$ npm i -D  thread-loader
复制代码
```

1. 配置

```js
const path = require('path');

// 路径处理方法
function resolve(dir){
  return path.join(__dirname, dir);
}

const config = {
  //...
  module: { 
    noParse: /jquery|lodash/,
    rules: [
      {
        test: /\.js$/i,
        include: resolve('src'),
        exclude: /node_modules/,
        use: [
          {
            loader: 'thread-loader', // 开启多进程打包
            options: {
              worker: 3,
            }
          },
          'babel-loader',
        ]
      },
      // ...
    ]
  }
};
复制代码
```

##### 1.5.2 happypack ❌

同样为开启多进程打包的工具，webpack5 已弃用。

#### 1.6 利用缓存

利用缓存可以大幅提升重复构建的速度

##### 1.6.1 babel-loader 开启缓存

+ babel 在转译 js 过程中时间开销比价大，将 babel-loader 的执行结果缓存起来，重新打包的时候，直接读取缓存
+ 缓存位置： `node_modules/.cache/babel-loader`

具体配置如下：

```js
const config = {
 module: { 
    noParse: /jquery|lodash/,
    rules: [
      {
        test: /\.js$/i,
        include: resolve('src'),
        exclude: /node_modules/,
        use: [
          // ...
          {
            loader: 'babel-loader',
            options: {
              cacheDirectory: true // 启用缓存
            }
          },
        ]
      },
      // ...
    ]
  }
}
复制代码
```

那其他的 loader 如何将结果缓存呢？

[cache-loader](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fcache-loader) 就可以帮我们完成这件事情

##### 1.6.2 cache-loader

+ 缓存一些性能开销比较大的 loader 的处理结果
+ 缓存位置：`node_modules/.cache/cache-loader`

1. 安装

```bash
$ npm i -D cache-loader
复制代码
```

1. 配置 cache-loader

```js
const config = {
 module: { 
    // ...
    rules: [
      {
        test: /\.(s[ac]|c)ss$/i, //匹配所有的 sass/scss/css 文件
        use: [
          // 'style-loader',
          MiniCssExtractPlugin.loader,
          'cache-loader', // 获取前面 loader 转换的结果
          'css-loader',
          'postcss-loader',
          'sass-loader', 
        ]
      }, 
      // ...
    ]
  }
}
复制代码
```

##### 1.6.3 hard-source-webpack-plugin

+ [hard-source-webpack-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmzgoddard%2Fhard-source-webpack-plugin) 为模块提供了中间缓存，重复构建时间大约可以减少 80%，但是在 **webpack5 中已经内置了模块缓存，不需要再使用此插件**

##### 1.6.5 cache 持久化缓存

通过配置 [cache](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fconfiguration%2Fcache%2F%23root) 缓存生成的 webpack 模块和 chunk，来改善构建速度。

```js
const config = {
  cache: {
    type: 'filesystem',
  },
};
```

#### 压缩 CSS

1. 安装 [`optimize-css-assets-webpack-plugin`](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Foptimize-css-assets-webpack-plugin)

```bash
$ npm install -D optimize-css-assets-webpack-plugin 
复制代码
```

1. 修改 `webapck.config.js` 配置

```js
// ...
// 压缩css
const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin')
// ...

const config = {
  // ...
  optimization: {
    minimize: true,
    minimizer: [
      // 添加 css 压缩配置
      new OptimizeCssAssetsPlugin({}),
    ]
  },
 // ...
}

// ...
```

#### splitChunks 分包配置

optimization.splitChunks 是基于 [SplitChunksPlugin](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fplugins%2Fsplit-chunks-plugin%2F) 插件实现的

默认情况下，它只会影响到按需加载的 chunks，因为修改 initial chunks 会影响到项目的 HTML 文件中的脚本标签。

webpack 将根据以下条件自动拆分 chunks：

+ 新的 chunk 可以被共享，或者模块来自于 `node_modules` 文件夹
+ 新的 chunk 体积大于 20kb（在进行 min+gz 之前的体积）
+ 当按需加载 chunks 时，并行请求的最大数量小于或等于 30
+ 当加载初始化页面时，并发请求的最大数量小于或等于 30

1. 默认配置介绍

```js
module.exports = {
  //...
  optimization: {
    splitChunks: {
      chunks: 'async', // 有效值为 `all`，`async` 和 `initial`
      minSize: 20000, // 生成 chunk 的最小体积（≈ 20kb)
      minRemainingSize: 0, // 确保拆分后剩余的最小 chunk 体积超过限制来避免大小为零的模块
      minChunks: 1, // 拆分前必须共享模块的最小 chunks 数。
      maxAsyncRequests: 30, // 最大的按需(异步)加载次数
      maxInitialRequests: 30, // 打包后的入口文件加载时，还能同时加载js文件的数量（包括入口文件）
      enforceSizeThreshold: 50000,
      cacheGroups: { // 配置提取模块的方案
        defaultVendors: {
          test: /[\/]node_modules[\/]/,
          priority: -10,
          reuseExistingChunk: true,
        },
        default: {
          minChunks: 2,
          priority: -20,
          reuseExistingChunk: true,
        },
      },
    },
  },
};
复制代码
```

1. 项目中的使用

```js
const config = {
  //...
  optimization: {
    splitChunks: {
      cacheGroups: { // 配置提取模块的方案
        default: false,
        styles: {
            name: 'styles',
            test: /\.(s?css|less|sass)$/,
            chunks: 'all',
            enforce: true,
            priority: 10,
          },
          common: {
            name: 'chunk-common',
            chunks: 'all',
            minChunks: 2,
            maxInitialRequests: 5,
            minSize: 0,
            priority: 1,
            enforce: true,
            reuseExistingChunk: true,
          },
          vendors: {
            name: 'chunk-vendors',
            test: /[\\/]node_modules[\\/]/,
            chunks: 'all',
            priority: 2,
            enforce: true,
            reuseExistingChunk: true,
          },
         // ... 根据不同项目再细化拆分内容
      },
    },
  },
}
```

#### prefetch 与 preload

上面我们使用异步加载的方式引入图片的描述，但是如果需要异步加载的文件比较大时，在点击的时候去加载也会影响到我们的体验，这个时候我们就可以考虑使用 prefetch 来进行预拉取

##### 3.4.1 prefetch

> + **prefetch** (预获取)：浏览器空闲的时候进行资源的拉取

改造一下上面的代码

```js
// 按需加载
img.addEventListener('click', () => {
  import( /* webpackPrefetch: true */ './desc').then(({ default: element }) => {
    console.log(element)
    document.body.appendChild(element)
  })
})
```

##### 3.4.2 preload

> + **preload** (预加载)：提前加载后面会用到的关键资源
> + ⚠️ 因为会提前拉取资源，如果不是特殊需要，谨慎使用

官网示例：

```js
import(/* webpackPreload: true */ 'ChartingLibrary');
```

## 图片

（1）**BMP**，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。

（2）**GIF**是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。

（3）**JPEG**是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。

（4）**PNG-8**是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。

（5）**PNG-24**是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。

（6）**SVG**是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。

（7）**WebP**是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。

+ 在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；
+ 在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；
+ WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。
